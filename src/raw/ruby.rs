/* automatically generated by rust-bindgen */
#![allow(non_camel_case_types, non_snake_case)]
extern crate libc;

pub type __int128_t = ::libc::c_void;
pub type __uint128_t = ::libc::c_void;
pub type __builtin_va_list = [__va_list_tag, ..1u];
pub type __int8_t = ::libc::c_char;
pub type __uint8_t = ::libc::c_uchar;
pub type __int16_t = ::libc::c_short;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_longlong;
pub type __uint64_t = ::libc::c_ulonglong;
pub type __darwin_intptr_t = ::libc::c_long;
pub type __darwin_natural_t = ::libc::c_uint;
pub type __darwin_ct_rune_t = ::libc::c_int;
#[repr(C)]
pub struct __mbstate_t {
    pub data: [u64, ..16u],
}
impl __mbstate_t {
    pub fn __mbstate8(&mut self) -> *mut [::libc::c_char, ..128u] {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn _mbstateL(&mut self) -> *mut ::libc::c_longlong {
        unsafe { ::std::mem::transmute(self) }
    }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::libc::c_long;
pub type __darwin_size_t = ::libc::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::libc::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::libc::c_int;
pub type __darwin_clock_t = ::libc::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::libc::c_long;
pub type __darwin_time_t = ::libc::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::libc::c_uint;
pub type __darwin_fsfilcnt_t = ::libc::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::libc::c_uchar, ..16u];
pub type __darwin_uuid_string_t = [::libc::c_char, ..37u];
#[repr(C)]
pub struct Struct___darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<extern "C" fn
                                             (arg1: *mut ::libc::c_void)>,
    pub __arg: *mut ::libc::c_void,
    pub __next: *mut Struct___darwin_pthread_handler_rec,
}
#[repr(C)]
pub struct Struct__opaque_pthread_attr_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char, ..56u],
}
#[repr(C)]
pub struct Struct__opaque_pthread_cond_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char, ..40u],
}
#[repr(C)]
pub struct Struct__opaque_pthread_condattr_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char, ..8u],
}
#[repr(C)]
pub struct Struct__opaque_pthread_mutex_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char, ..56u],
}
#[repr(C)]
pub struct Struct__opaque_pthread_mutexattr_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char, ..8u],
}
#[repr(C)]
pub struct Struct__opaque_pthread_once_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char, ..8u],
}
#[repr(C)]
pub struct Struct__opaque_pthread_rwlock_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char, ..192u],
}
#[repr(C)]
pub struct Struct__opaque_pthread_rwlockattr_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char, ..16u],
}
#[repr(C)]
pub struct Struct__opaque_pthread_t {
    pub __sig: ::libc::c_long,
    pub __cleanup_stack: *mut Struct___darwin_pthread_handler_rec,
    pub __opaque: [::libc::c_char, ..8176u],
}
pub type __darwin_pthread_attr_t = Struct__opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = Struct__opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = Struct__opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::libc::c_ulong;
pub type __darwin_pthread_mutex_t = Struct__opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = Struct__opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = Struct__opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = Struct__opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = Struct__opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut Struct__opaque_pthread_t;
pub type __darwin_nl_item = ::libc::c_int;
pub type __darwin_wctrans_t = ::libc::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type va_list = __darwin_va_list;
pub type size_t = __darwin_size_t;
pub type fpos_t = __darwin_off_t;
#[repr(C)]
pub struct Struct___sbuf {
    pub _base: *mut ::libc::c_uchar,
    pub _size: ::libc::c_int,
}
pub enum Struct___sFILEX { }
#[repr(C)]
pub struct Struct___sFILE {
    pub _p: *mut ::libc::c_uchar,
    pub _r: ::libc::c_int,
    pub _w: ::libc::c_int,
    pub _flags: ::libc::c_short,
    pub _file: ::libc::c_short,
    pub _bf: Struct___sbuf,
    pub _lbfsize: ::libc::c_int,
    pub _cookie: *mut ::libc::c_void,
    pub _close: ::std::option::Option<extern "C" fn(arg1: *mut ::libc::c_void)
                                          -> ::libc::c_int>,
    pub _read: ::std::option::Option<extern "C" fn
                                         (arg1: *mut ::libc::c_void,
                                          arg2: *mut ::libc::c_char,
                                          arg3: ::libc::c_int)
                                         -> ::libc::c_int>,
    pub _seek: ::std::option::Option<extern "C" fn
                                         (arg1: *mut ::libc::c_void,
                                          arg2: fpos_t, arg3: ::libc::c_int)
                                         -> fpos_t>,
    pub _write: ::std::option::Option<extern "C" fn
                                          (arg1: *mut ::libc::c_void,
                                           arg2: *const ::libc::c_char,
                                           arg3: ::libc::c_int)
                                          -> ::libc::c_int>,
    pub _ub: Struct___sbuf,
    pub _extra: *mut Struct___sFILEX,
    pub _ur: ::libc::c_int,
    pub _ubuf: [::libc::c_uchar, ..3u],
    pub _nbuf: [::libc::c_uchar, ..1u],
    pub _lb: Struct___sbuf,
    pub _blksize: ::libc::c_int,
    pub _offset: fpos_t,
}
pub type FILE = Struct___sFILE;
pub type off_t = __darwin_off_t;
pub type ssize_t = __darwin_ssize_t;
pub type int8_t = ::libc::c_char;
pub type int16_t = ::libc::c_short;
pub type int32_t = ::libc::c_int;
pub type int64_t = ::libc::c_longlong;
pub type u_int8_t = ::libc::c_uchar;
pub type u_int16_t = ::libc::c_ushort;
pub type u_int32_t = ::libc::c_uint;
pub type u_int64_t = ::libc::c_ulonglong;
pub type register_t = int64_t;
pub type intptr_t = __darwin_intptr_t;
pub type uintptr_t = ::libc::c_ulong;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = int64_t;
pub type user_long_t = int64_t;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = int64_t;
pub type user_off_t = int64_t;
pub type syscall_arg_t = u_int64_t;
pub type u_char = ::libc::c_uchar;
pub type u_short = ::libc::c_ushort;
pub type u_int = ::libc::c_uint;
pub type u_long = ::libc::c_ulong;
pub type ushort = ::libc::c_ushort;
pub type _uint = ::libc::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = int64_t;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::libc::c_char;
pub type daddr_t = int32_t;
pub type dev_t = __darwin_dev_t;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type mode_t = __darwin_mode_t;
pub type nlink_t = __uint16_t;
pub type id_t = __darwin_id_t;
pub type pid_t = __darwin_pid_t;
pub type segsz_t = int32_t;
pub type swblk_t = int32_t;
pub type uid_t = __darwin_uid_t;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::libc::c_int;
#[repr(C)]
pub struct Struct_fd_set {
    pub fds_bits: [__int32_t, ..32u],
}
pub type fd_set = Struct_fd_set;
pub type fd_mask = __int32_t;
pub type pthread_attr_t = __darwin_pthread_attr_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
#[repr(C)]
pub struct Struct_timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::libc::c_long,
}
#[repr(C)]
pub struct Struct_ostat {
    pub st_dev: __uint16_t,
    pub st_ino: ino_t,
    pub st_mode: mode_t,
    pub st_nlink: nlink_t,
    pub st_uid: __uint16_t,
    pub st_gid: __uint16_t,
    pub st_rdev: __uint16_t,
    pub st_size: __int32_t,
    pub st_atimespec: Struct_timespec,
    pub st_mtimespec: Struct_timespec,
    pub st_ctimespec: Struct_timespec,
    pub st_blksize: __int32_t,
    pub st_blocks: __int32_t,
    pub st_flags: __uint32_t,
    pub st_gen: __uint32_t,
}
#[repr(C)]
pub struct Struct_stat {
    pub st_dev: dev_t,
    pub st_mode: mode_t,
    pub st_nlink: nlink_t,
    pub st_ino: __darwin_ino64_t,
    pub st_uid: uid_t,
    pub st_gid: gid_t,
    pub st_rdev: dev_t,
    pub st_atimespec: Struct_timespec,
    pub st_mtimespec: Struct_timespec,
    pub st_ctimespec: Struct_timespec,
    pub st_birthtimespec: Struct_timespec,
    pub st_size: off_t,
    pub st_blocks: blkcnt_t,
    pub st_blksize: blksize_t,
    pub st_flags: __uint32_t,
    pub st_gen: __uint32_t,
    pub st_lspare: __int32_t,
    pub st_qspare: [__int64_t, ..2u],
}
#[repr(C)]
pub struct Struct_stat64 {
    pub st_dev: dev_t,
    pub st_mode: mode_t,
    pub st_nlink: nlink_t,
    pub st_ino: __darwin_ino64_t,
    pub st_uid: uid_t,
    pub st_gid: gid_t,
    pub st_rdev: dev_t,
    pub st_atimespec: Struct_timespec,
    pub st_mtimespec: Struct_timespec,
    pub st_ctimespec: Struct_timespec,
    pub st_birthtimespec: Struct_timespec,
    pub st_size: off_t,
    pub st_blocks: blkcnt_t,
    pub st_blksize: blksize_t,
    pub st_flags: __uint32_t,
    pub st_gen: __uint32_t,
    pub st_lspare: __int32_t,
    pub st_qspare: [__int64_t, ..2u],
}
pub enum Struct__filesec { }
pub type filesec_t = *mut Struct__filesec;
pub type idtype_t = ::libc::c_uint;
pub static P_ALL: ::libc::c_uint = 0;
pub static P_PID: ::libc::c_uint = 1;
pub static P_PGID: ::libc::c_uint = 2;
pub type sig_atomic_t = ::libc::c_int;
#[repr(C)]
pub struct Struct___darwin_i386_thread_state {
    pub __eax: ::libc::c_uint,
    pub __ebx: ::libc::c_uint,
    pub __ecx: ::libc::c_uint,
    pub __edx: ::libc::c_uint,
    pub __edi: ::libc::c_uint,
    pub __esi: ::libc::c_uint,
    pub __ebp: ::libc::c_uint,
    pub __esp: ::libc::c_uint,
    pub __ss: ::libc::c_uint,
    pub __eflags: ::libc::c_uint,
    pub __eip: ::libc::c_uint,
    pub __cs: ::libc::c_uint,
    pub __ds: ::libc::c_uint,
    pub __es: ::libc::c_uint,
    pub __fs: ::libc::c_uint,
    pub __gs: ::libc::c_uint,
}
#[repr(C)]
pub struct Struct___darwin_fp_control {
    pub __invalid: ::libc::c_ushort,
    pub __denorm: ::libc::c_ushort,
    pub __zdiv: ::libc::c_ushort,
    pub __ovrfl: ::libc::c_ushort,
    pub __undfl: ::libc::c_ushort,
    pub __precis: ::libc::c_ushort,
    pub unnamed_field1: ::libc::c_ushort,
    pub __pc: ::libc::c_ushort,
    pub __rc: ::libc::c_ushort,
    pub unnamed_field2: ::libc::c_ushort,
    pub unnamed_field3: ::libc::c_ushort,
}
pub type __darwin_fp_control_t = Struct___darwin_fp_control;
#[repr(C)]
pub struct Struct___darwin_fp_status {
    pub __invalid: ::libc::c_ushort,
    pub __denorm: ::libc::c_ushort,
    pub __zdiv: ::libc::c_ushort,
    pub __ovrfl: ::libc::c_ushort,
    pub __undfl: ::libc::c_ushort,
    pub __precis: ::libc::c_ushort,
    pub __stkflt: ::libc::c_ushort,
    pub __errsumm: ::libc::c_ushort,
    pub __c0: ::libc::c_ushort,
    pub __c1: ::libc::c_ushort,
    pub __c2: ::libc::c_ushort,
    pub __tos: ::libc::c_ushort,
    pub __c3: ::libc::c_ushort,
    pub __busy: ::libc::c_ushort,
}
pub type __darwin_fp_status_t = Struct___darwin_fp_status;
#[repr(C)]
pub struct Struct___darwin_mmst_reg {
    pub __mmst_reg: [::libc::c_char, ..10u],
    pub __mmst_rsrv: [::libc::c_char, ..6u],
}
#[repr(C)]
pub struct Struct___darwin_xmm_reg {
    pub __xmm_reg: [::libc::c_char, ..16u],
}
#[repr(C)]
pub struct Struct___darwin_i386_float_state {
    pub __fpu_reserved: [::libc::c_int, ..2u],
    pub __fpu_fcw: Struct___darwin_fp_control,
    pub __fpu_fsw: Struct___darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: Struct___darwin_mmst_reg,
    pub __fpu_stmm1: Struct___darwin_mmst_reg,
    pub __fpu_stmm2: Struct___darwin_mmst_reg,
    pub __fpu_stmm3: Struct___darwin_mmst_reg,
    pub __fpu_stmm4: Struct___darwin_mmst_reg,
    pub __fpu_stmm5: Struct___darwin_mmst_reg,
    pub __fpu_stmm6: Struct___darwin_mmst_reg,
    pub __fpu_stmm7: Struct___darwin_mmst_reg,
    pub __fpu_xmm0: Struct___darwin_xmm_reg,
    pub __fpu_xmm1: Struct___darwin_xmm_reg,
    pub __fpu_xmm2: Struct___darwin_xmm_reg,
    pub __fpu_xmm3: Struct___darwin_xmm_reg,
    pub __fpu_xmm4: Struct___darwin_xmm_reg,
    pub __fpu_xmm5: Struct___darwin_xmm_reg,
    pub __fpu_xmm6: Struct___darwin_xmm_reg,
    pub __fpu_xmm7: Struct___darwin_xmm_reg,
    pub __fpu_rsrv4: [::libc::c_char, ..224u],
    pub __fpu_reserved1: ::libc::c_int,
}
#[repr(C)]
pub struct Struct___darwin_i386_avx_state {
    pub __fpu_reserved: [::libc::c_int, ..2u],
    pub __fpu_fcw: Struct___darwin_fp_control,
    pub __fpu_fsw: Struct___darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: Struct___darwin_mmst_reg,
    pub __fpu_stmm1: Struct___darwin_mmst_reg,
    pub __fpu_stmm2: Struct___darwin_mmst_reg,
    pub __fpu_stmm3: Struct___darwin_mmst_reg,
    pub __fpu_stmm4: Struct___darwin_mmst_reg,
    pub __fpu_stmm5: Struct___darwin_mmst_reg,
    pub __fpu_stmm6: Struct___darwin_mmst_reg,
    pub __fpu_stmm7: Struct___darwin_mmst_reg,
    pub __fpu_xmm0: Struct___darwin_xmm_reg,
    pub __fpu_xmm1: Struct___darwin_xmm_reg,
    pub __fpu_xmm2: Struct___darwin_xmm_reg,
    pub __fpu_xmm3: Struct___darwin_xmm_reg,
    pub __fpu_xmm4: Struct___darwin_xmm_reg,
    pub __fpu_xmm5: Struct___darwin_xmm_reg,
    pub __fpu_xmm6: Struct___darwin_xmm_reg,
    pub __fpu_xmm7: Struct___darwin_xmm_reg,
    pub __fpu_rsrv4: [::libc::c_char, ..224u],
    pub __fpu_reserved1: ::libc::c_int,
    pub __avx_reserved1: [::libc::c_char, ..64u],
    pub __fpu_ymmh0: Struct___darwin_xmm_reg,
    pub __fpu_ymmh1: Struct___darwin_xmm_reg,
    pub __fpu_ymmh2: Struct___darwin_xmm_reg,
    pub __fpu_ymmh3: Struct___darwin_xmm_reg,
    pub __fpu_ymmh4: Struct___darwin_xmm_reg,
    pub __fpu_ymmh5: Struct___darwin_xmm_reg,
    pub __fpu_ymmh6: Struct___darwin_xmm_reg,
    pub __fpu_ymmh7: Struct___darwin_xmm_reg,
}
#[repr(C)]
pub struct Struct___darwin_i386_exception_state {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint32_t,
}
#[repr(C)]
pub struct Struct___darwin_x86_debug_state32 {
    pub __dr0: ::libc::c_uint,
    pub __dr1: ::libc::c_uint,
    pub __dr2: ::libc::c_uint,
    pub __dr3: ::libc::c_uint,
    pub __dr4: ::libc::c_uint,
    pub __dr5: ::libc::c_uint,
    pub __dr6: ::libc::c_uint,
    pub __dr7: ::libc::c_uint,
}
#[repr(C)]
pub struct Struct___darwin_x86_thread_state64 {
    pub __rax: __uint64_t,
    pub __rbx: __uint64_t,
    pub __rcx: __uint64_t,
    pub __rdx: __uint64_t,
    pub __rdi: __uint64_t,
    pub __rsi: __uint64_t,
    pub __rbp: __uint64_t,
    pub __rsp: __uint64_t,
    pub __r8: __uint64_t,
    pub __r9: __uint64_t,
    pub __r10: __uint64_t,
    pub __r11: __uint64_t,
    pub __r12: __uint64_t,
    pub __r13: __uint64_t,
    pub __r14: __uint64_t,
    pub __r15: __uint64_t,
    pub __rip: __uint64_t,
    pub __rflags: __uint64_t,
    pub __cs: __uint64_t,
    pub __fs: __uint64_t,
    pub __gs: __uint64_t,
}
#[repr(C)]
pub struct Struct___darwin_x86_float_state64 {
    pub __fpu_reserved: [::libc::c_int, ..2u],
    pub __fpu_fcw: Struct___darwin_fp_control,
    pub __fpu_fsw: Struct___darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: Struct___darwin_mmst_reg,
    pub __fpu_stmm1: Struct___darwin_mmst_reg,
    pub __fpu_stmm2: Struct___darwin_mmst_reg,
    pub __fpu_stmm3: Struct___darwin_mmst_reg,
    pub __fpu_stmm4: Struct___darwin_mmst_reg,
    pub __fpu_stmm5: Struct___darwin_mmst_reg,
    pub __fpu_stmm6: Struct___darwin_mmst_reg,
    pub __fpu_stmm7: Struct___darwin_mmst_reg,
    pub __fpu_xmm0: Struct___darwin_xmm_reg,
    pub __fpu_xmm1: Struct___darwin_xmm_reg,
    pub __fpu_xmm2: Struct___darwin_xmm_reg,
    pub __fpu_xmm3: Struct___darwin_xmm_reg,
    pub __fpu_xmm4: Struct___darwin_xmm_reg,
    pub __fpu_xmm5: Struct___darwin_xmm_reg,
    pub __fpu_xmm6: Struct___darwin_xmm_reg,
    pub __fpu_xmm7: Struct___darwin_xmm_reg,
    pub __fpu_xmm8: Struct___darwin_xmm_reg,
    pub __fpu_xmm9: Struct___darwin_xmm_reg,
    pub __fpu_xmm10: Struct___darwin_xmm_reg,
    pub __fpu_xmm11: Struct___darwin_xmm_reg,
    pub __fpu_xmm12: Struct___darwin_xmm_reg,
    pub __fpu_xmm13: Struct___darwin_xmm_reg,
    pub __fpu_xmm14: Struct___darwin_xmm_reg,
    pub __fpu_xmm15: Struct___darwin_xmm_reg,
    pub __fpu_rsrv4: [::libc::c_char, ..96u],
    pub __fpu_reserved1: ::libc::c_int,
}
#[repr(C)]
pub struct Struct___darwin_x86_avx_state64 {
    pub __fpu_reserved: [::libc::c_int, ..2u],
    pub __fpu_fcw: Struct___darwin_fp_control,
    pub __fpu_fsw: Struct___darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: Struct___darwin_mmst_reg,
    pub __fpu_stmm1: Struct___darwin_mmst_reg,
    pub __fpu_stmm2: Struct___darwin_mmst_reg,
    pub __fpu_stmm3: Struct___darwin_mmst_reg,
    pub __fpu_stmm4: Struct___darwin_mmst_reg,
    pub __fpu_stmm5: Struct___darwin_mmst_reg,
    pub __fpu_stmm6: Struct___darwin_mmst_reg,
    pub __fpu_stmm7: Struct___darwin_mmst_reg,
    pub __fpu_xmm0: Struct___darwin_xmm_reg,
    pub __fpu_xmm1: Struct___darwin_xmm_reg,
    pub __fpu_xmm2: Struct___darwin_xmm_reg,
    pub __fpu_xmm3: Struct___darwin_xmm_reg,
    pub __fpu_xmm4: Struct___darwin_xmm_reg,
    pub __fpu_xmm5: Struct___darwin_xmm_reg,
    pub __fpu_xmm6: Struct___darwin_xmm_reg,
    pub __fpu_xmm7: Struct___darwin_xmm_reg,
    pub __fpu_xmm8: Struct___darwin_xmm_reg,
    pub __fpu_xmm9: Struct___darwin_xmm_reg,
    pub __fpu_xmm10: Struct___darwin_xmm_reg,
    pub __fpu_xmm11: Struct___darwin_xmm_reg,
    pub __fpu_xmm12: Struct___darwin_xmm_reg,
    pub __fpu_xmm13: Struct___darwin_xmm_reg,
    pub __fpu_xmm14: Struct___darwin_xmm_reg,
    pub __fpu_xmm15: Struct___darwin_xmm_reg,
    pub __fpu_rsrv4: [::libc::c_char, ..96u],
    pub __fpu_reserved1: ::libc::c_int,
    pub __avx_reserved1: [::libc::c_char, ..64u],
    pub __fpu_ymmh0: Struct___darwin_xmm_reg,
    pub __fpu_ymmh1: Struct___darwin_xmm_reg,
    pub __fpu_ymmh2: Struct___darwin_xmm_reg,
    pub __fpu_ymmh3: Struct___darwin_xmm_reg,
    pub __fpu_ymmh4: Struct___darwin_xmm_reg,
    pub __fpu_ymmh5: Struct___darwin_xmm_reg,
    pub __fpu_ymmh6: Struct___darwin_xmm_reg,
    pub __fpu_ymmh7: Struct___darwin_xmm_reg,
    pub __fpu_ymmh8: Struct___darwin_xmm_reg,
    pub __fpu_ymmh9: Struct___darwin_xmm_reg,
    pub __fpu_ymmh10: Struct___darwin_xmm_reg,
    pub __fpu_ymmh11: Struct___darwin_xmm_reg,
    pub __fpu_ymmh12: Struct___darwin_xmm_reg,
    pub __fpu_ymmh13: Struct___darwin_xmm_reg,
    pub __fpu_ymmh14: Struct___darwin_xmm_reg,
    pub __fpu_ymmh15: Struct___darwin_xmm_reg,
}
#[repr(C)]
pub struct Struct___darwin_x86_exception_state64 {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint64_t,
}
#[repr(C)]
pub struct Struct___darwin_x86_debug_state64 {
    pub __dr0: __uint64_t,
    pub __dr1: __uint64_t,
    pub __dr2: __uint64_t,
    pub __dr3: __uint64_t,
    pub __dr4: __uint64_t,
    pub __dr5: __uint64_t,
    pub __dr6: __uint64_t,
    pub __dr7: __uint64_t,
}
#[repr(C)]
pub struct Struct___darwin_mcontext32 {
    pub __es: Struct___darwin_i386_exception_state,
    pub __ss: Struct___darwin_i386_thread_state,
    pub __fs: Struct___darwin_i386_float_state,
}
#[repr(C)]
pub struct Struct___darwin_mcontext_avx32 {
    pub __es: Struct___darwin_i386_exception_state,
    pub __ss: Struct___darwin_i386_thread_state,
    pub __fs: Struct___darwin_i386_avx_state,
}
#[repr(C)]
pub struct Struct___darwin_mcontext64 {
    pub __es: Struct___darwin_x86_exception_state64,
    pub __ss: Struct___darwin_x86_thread_state64,
    pub __fs: Struct___darwin_x86_float_state64,
}
#[repr(C)]
pub struct Struct___darwin_mcontext_avx64 {
    pub __es: Struct___darwin_x86_exception_state64,
    pub __ss: Struct___darwin_x86_thread_state64,
    pub __fs: Struct___darwin_x86_avx_state64,
}
pub type mcontext_t = *mut Struct___darwin_mcontext64;
#[repr(C)]
pub struct Struct___darwin_sigaltstack {
    pub ss_sp: *mut ::libc::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::libc::c_int,
}
pub type stack_t = Struct___darwin_sigaltstack;
#[repr(C)]
pub struct Struct___darwin_ucontext {
    pub uc_onstack: ::libc::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: Struct___darwin_sigaltstack,
    pub uc_link: *mut Struct___darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut Struct___darwin_mcontext64,
}
pub type ucontext_t = Struct___darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
#[repr(C)]
pub struct Union_sigval {
    pub data: [u64, ..1u],
}
impl Union_sigval {
    pub fn sival_int(&mut self) -> *mut ::libc::c_int {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn sival_ptr(&mut self) -> *mut *mut ::libc::c_void {
        unsafe { ::std::mem::transmute(self) }
    }
}
#[repr(C)]
pub struct Struct_sigevent {
    pub sigev_notify: ::libc::c_int,
    pub sigev_signo: ::libc::c_int,
    pub sigev_value: Union_sigval,
    pub sigev_notify_function: ::std::option::Option<extern "C" fn
                                                         (arg1:
                                                              Union_sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[repr(C)]
pub struct Struct___siginfo {
    pub si_signo: ::libc::c_int,
    pub si_errno: ::libc::c_int,
    pub si_code: ::libc::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::libc::c_int,
    pub si_addr: *mut ::libc::c_void,
    pub si_value: Union_sigval,
    pub si_band: ::libc::c_long,
    pub __pad: [::libc::c_ulong, ..7u],
}
pub type siginfo_t = Struct___siginfo;
#[repr(C)]
pub struct Union___sigaction_u {
    pub data: [u64, ..1u],
}
impl Union___sigaction_u {
    pub fn __sa_handler(&mut self) ->
     *mut ::std::option::Option<extern "C" fn(arg1: ::libc::c_int)> {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn __sa_sigaction(&mut self) ->
     *mut ::std::option::Option<extern "C" fn
                                    (arg1: ::libc::c_int,
                                     arg2: *mut Struct___siginfo,
                                     arg3: *mut ::libc::c_void)> {
        unsafe { ::std::mem::transmute(self) }
    }
}
#[repr(C)]
pub struct Struct___sigaction {
    pub __sigaction_u: Union___sigaction_u,
    pub sa_tramp: ::std::option::Option<extern "C" fn
                                            (arg1: *mut ::libc::c_void,
                                             arg2: ::libc::c_int,
                                             arg3: ::libc::c_int,
                                             arg4: *mut siginfo_t,
                                             arg5: *mut ::libc::c_void)>,
    pub sa_mask: sigset_t,
    pub sa_flags: ::libc::c_int,
}
#[repr(C)]
pub struct Struct_sigaction {
    pub __sigaction_u: Union___sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::libc::c_int,
}
pub type sig_t = ::std::option::Option<extern "C" fn(arg1: ::libc::c_int)>;
#[repr(C)]
pub struct Struct_sigvec {
    pub sv_handler: ::std::option::Option<extern "C" fn(arg1: ::libc::c_int)>,
    pub sv_mask: ::libc::c_int,
    pub sv_flags: ::libc::c_int,
}
#[repr(C)]
pub struct Struct_sigstack {
    pub ss_sp: *mut ::libc::c_char,
    pub ss_onstack: ::libc::c_int,
}
pub type uint8_t = ::libc::c_uchar;
pub type uint16_t = ::libc::c_ushort;
pub type uint32_t = ::libc::c_uint;
pub type uint64_t = ::libc::c_ulonglong;
pub type int_least8_t = int8_t;
pub type int_least16_t = int16_t;
pub type int_least32_t = int32_t;
pub type int_least64_t = int64_t;
pub type uint_least8_t = uint8_t;
pub type uint_least16_t = uint16_t;
pub type uint_least32_t = uint32_t;
pub type uint_least64_t = uint64_t;
pub type int_fast8_t = int8_t;
pub type int_fast16_t = int16_t;
pub type int_fast32_t = int32_t;
pub type int_fast64_t = int64_t;
pub type uint_fast8_t = uint8_t;
pub type uint_fast16_t = uint16_t;
pub type uint_fast32_t = uint32_t;
pub type uint_fast64_t = uint64_t;
pub type intmax_t = ::libc::c_long;
pub type uintmax_t = ::libc::c_ulong;
#[repr(C)]
pub struct Struct_timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
pub type rlim_t = __uint64_t;
#[repr(C)]
pub struct Struct_rusage {
    pub ru_utime: Struct_timeval,
    pub ru_stime: Struct_timeval,
    pub ru_maxrss: ::libc::c_long,
    pub ru_ixrss: ::libc::c_long,
    pub ru_idrss: ::libc::c_long,
    pub ru_isrss: ::libc::c_long,
    pub ru_minflt: ::libc::c_long,
    pub ru_majflt: ::libc::c_long,
    pub ru_nswap: ::libc::c_long,
    pub ru_inblock: ::libc::c_long,
    pub ru_oublock: ::libc::c_long,
    pub ru_msgsnd: ::libc::c_long,
    pub ru_msgrcv: ::libc::c_long,
    pub ru_nsignals: ::libc::c_long,
    pub ru_nvcsw: ::libc::c_long,
    pub ru_nivcsw: ::libc::c_long,
}
pub type rusage_info_t = *mut ::libc::c_void;
#[repr(C)]
pub struct Struct_rusage_info_v0 {
    pub ri_uuid: [uint8_t, ..16u],
    pub ri_user_time: uint64_t,
    pub ri_system_time: uint64_t,
    pub ri_pkg_idle_wkups: uint64_t,
    pub ri_interrupt_wkups: uint64_t,
    pub ri_pageins: uint64_t,
    pub ri_wired_size: uint64_t,
    pub ri_resident_size: uint64_t,
    pub ri_phys_footprint: uint64_t,
    pub ri_proc_start_abstime: uint64_t,
    pub ri_proc_exit_abstime: uint64_t,
}
#[repr(C)]
pub struct Struct_rusage_info_v1 {
    pub ri_uuid: [uint8_t, ..16u],
    pub ri_user_time: uint64_t,
    pub ri_system_time: uint64_t,
    pub ri_pkg_idle_wkups: uint64_t,
    pub ri_interrupt_wkups: uint64_t,
    pub ri_pageins: uint64_t,
    pub ri_wired_size: uint64_t,
    pub ri_resident_size: uint64_t,
    pub ri_phys_footprint: uint64_t,
    pub ri_proc_start_abstime: uint64_t,
    pub ri_proc_exit_abstime: uint64_t,
    pub ri_child_user_time: uint64_t,
    pub ri_child_system_time: uint64_t,
    pub ri_child_pkg_idle_wkups: uint64_t,
    pub ri_child_interrupt_wkups: uint64_t,
    pub ri_child_pageins: uint64_t,
    pub ri_child_elapsed_abstime: uint64_t,
}
#[repr(C)]
pub struct Struct_rusage_info_v2 {
    pub ri_uuid: [uint8_t, ..16u],
    pub ri_user_time: uint64_t,
    pub ri_system_time: uint64_t,
    pub ri_pkg_idle_wkups: uint64_t,
    pub ri_interrupt_wkups: uint64_t,
    pub ri_pageins: uint64_t,
    pub ri_wired_size: uint64_t,
    pub ri_resident_size: uint64_t,
    pub ri_phys_footprint: uint64_t,
    pub ri_proc_start_abstime: uint64_t,
    pub ri_proc_exit_abstime: uint64_t,
    pub ri_child_user_time: uint64_t,
    pub ri_child_system_time: uint64_t,
    pub ri_child_pkg_idle_wkups: uint64_t,
    pub ri_child_interrupt_wkups: uint64_t,
    pub ri_child_pageins: uint64_t,
    pub ri_child_elapsed_abstime: uint64_t,
    pub ri_diskio_bytesread: uint64_t,
    pub ri_diskio_byteswritten: uint64_t,
}
#[repr(C)]
pub struct Struct_rusage_info_v3 {
    pub ri_uuid: [uint8_t, ..16u],
    pub ri_user_time: uint64_t,
    pub ri_system_time: uint64_t,
    pub ri_pkg_idle_wkups: uint64_t,
    pub ri_interrupt_wkups: uint64_t,
    pub ri_pageins: uint64_t,
    pub ri_wired_size: uint64_t,
    pub ri_resident_size: uint64_t,
    pub ri_phys_footprint: uint64_t,
    pub ri_proc_start_abstime: uint64_t,
    pub ri_proc_exit_abstime: uint64_t,
    pub ri_child_user_time: uint64_t,
    pub ri_child_system_time: uint64_t,
    pub ri_child_pkg_idle_wkups: uint64_t,
    pub ri_child_interrupt_wkups: uint64_t,
    pub ri_child_pageins: uint64_t,
    pub ri_child_elapsed_abstime: uint64_t,
    pub ri_diskio_bytesread: uint64_t,
    pub ri_diskio_byteswritten: uint64_t,
    pub ri_cpu_time_qos_default: uint64_t,
    pub ri_cpu_time_qos_maintenance: uint64_t,
    pub ri_cpu_time_qos_background: uint64_t,
    pub ri_cpu_time_qos_utility: uint64_t,
    pub ri_cpu_time_qos_legacy: uint64_t,
    pub ri_cpu_time_qos_user_initiated: uint64_t,
    pub ri_cpu_time_qos_user_interactive: uint64_t,
    pub ri_billed_system_time: uint64_t,
    pub ri_serviced_system_time: uint64_t,
}
pub type rusage_info_current = Struct_rusage_info_v3;
#[repr(C)]
pub struct Struct_rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[repr(C)]
pub struct Struct_proc_rlimit_control_wakeupmon {
    pub wm_flags: uint32_t,
    pub wm_rate: int32_t,
}
#[repr(C)]
pub struct Union_wait {
    pub data: [u32, ..1u],
}
impl Union_wait {
    pub fn w_status(&mut self) -> *mut ::libc::c_int {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn w_T(&mut self) -> *mut Struct_Unnamed1 {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn w_S(&mut self) -> *mut Struct_Unnamed2 {
        unsafe { ::std::mem::transmute(self) }
    }
}
#[repr(C)]
pub struct Struct_Unnamed1 {
    pub w_Termsig: ::libc::c_uint,
    pub w_Coredump: ::libc::c_uint,
    pub w_Retcode: ::libc::c_uint,
    pub w_Filler: ::libc::c_uint,
}
#[repr(C)]
pub struct Struct_Unnamed2 {
    pub w_Stopval: ::libc::c_uint,
    pub w_Stopsig: ::libc::c_uint,
    pub w_Filler: ::libc::c_uint,
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
pub type wchar_t = __darwin_wchar_t;
#[repr(C)]
pub struct div_t {
    pub quot: ::libc::c_int,
    pub rem: ::libc::c_int,
}
#[repr(C)]
pub struct ldiv_t {
    pub quot: ::libc::c_long,
    pub rem: ::libc::c_long,
}
#[repr(C)]
pub struct lldiv_t {
    pub quot: ::libc::c_longlong,
    pub rem: ::libc::c_longlong,
}
pub type ptrdiff_t = ::libc::c_long;
#[repr(C)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[repr(C)]
pub struct Struct_accessx_descriptor {
    pub ad_name_offset: ::libc::c_uint,
    pub ad_flags: ::libc::c_int,
    pub ad_pad: [::libc::c_int, ..2u],
}
pub type uuid_t = __darwin_uuid_t;
pub enum Struct_fssearchblock { }
pub enum Struct_searchstate { }
pub type float_t = ::libc::c_float;
pub type double_t = ::libc::c_double;
#[repr(C)]
pub struct Struct___float2 {
    pub __sinval: ::libc::c_float,
    pub __cosval: ::libc::c_float,
}
#[repr(C)]
pub struct Struct___double2 {
    pub __sinval: ::libc::c_double,
    pub __cosval: ::libc::c_double,
}
#[repr(C)]
pub struct Struct_exception {
    pub _type: ::libc::c_int,
    pub name: *mut ::libc::c_char,
    pub arg1: ::libc::c_double,
    pub arg2: ::libc::c_double,
    pub retval: ::libc::c_double,
}
pub type __gnuc_va_list = __builtin_va_list;
pub type VALUE = ::libc::c_ulong;
pub type ID = ::libc::c_ulong;
pub type ruby_check_sizeof_int = [::libc::c_char, ..1u];
pub type ruby_check_sizeof_long = [::libc::c_char, ..1u];
pub type ruby_check_sizeof_long_long = [::libc::c_char, ..1u];
pub type ruby_check_sizeof_voidp = [::libc::c_char, ..1u];
pub type Enum_ruby_special_consts = ::libc::c_uint;
pub static RUBY_Qfalse: ::libc::c_uint = 0;
pub static RUBY_Qtrue: ::libc::c_uint = 20;
pub static RUBY_Qnil: ::libc::c_uint = 8;
pub static RUBY_Qundef: ::libc::c_uint = 52;
pub static RUBY_IMMEDIATE_MASK: ::libc::c_uint = 7;
pub static RUBY_FIXNUM_FLAG: ::libc::c_uint = 1;
pub static RUBY_FLONUM_MASK: ::libc::c_uint = 3;
pub static RUBY_FLONUM_FLAG: ::libc::c_uint = 2;
pub static RUBY_SYMBOL_FLAG: ::libc::c_uint = 12;
pub static RUBY_SPECIAL_SHIFT: ::libc::c_uint = 8;
pub type Enum_ruby_value_type = ::libc::c_uint;
pub static RUBY_T_NONE: ::libc::c_uint = 0;
pub static RUBY_T_OBJECT: ::libc::c_uint = 1;
pub static RUBY_T_CLASS: ::libc::c_uint = 2;
pub static RUBY_T_MODULE: ::libc::c_uint = 3;
pub static RUBY_T_FLOAT: ::libc::c_uint = 4;
pub static RUBY_T_STRING: ::libc::c_uint = 5;
pub static RUBY_T_REGEXP: ::libc::c_uint = 6;
pub static RUBY_T_ARRAY: ::libc::c_uint = 7;
pub static RUBY_T_HASH: ::libc::c_uint = 8;
pub static RUBY_T_STRUCT: ::libc::c_uint = 9;
pub static RUBY_T_BIGNUM: ::libc::c_uint = 10;
pub static RUBY_T_FILE: ::libc::c_uint = 11;
pub static RUBY_T_DATA: ::libc::c_uint = 12;
pub static RUBY_T_MATCH: ::libc::c_uint = 13;
pub static RUBY_T_COMPLEX: ::libc::c_uint = 14;
pub static RUBY_T_RATIONAL: ::libc::c_uint = 15;
pub static RUBY_T_NIL: ::libc::c_uint = 17;
pub static RUBY_T_TRUE: ::libc::c_uint = 18;
pub static RUBY_T_FALSE: ::libc::c_uint = 19;
pub static RUBY_T_SYMBOL: ::libc::c_uint = 20;
pub static RUBY_T_FIXNUM: ::libc::c_uint = 21;
pub static RUBY_T_UNDEF: ::libc::c_uint = 27;
pub static RUBY_T_NODE: ::libc::c_uint = 28;
pub static RUBY_T_ICLASS: ::libc::c_uint = 29;
pub static RUBY_T_ZOMBIE: ::libc::c_uint = 30;
pub static RUBY_T_MASK: ::libc::c_uint = 31;
#[repr(C)]
pub struct Struct_RBasic {
    pub flags: VALUE,
    pub klass: VALUE,
}
#[repr(C)]
pub struct Struct_RObject {
    pub basic: Struct_RBasic,
    pub _as: Union_Unnamed3,
}
#[repr(C)]
pub struct Union_Unnamed3 {
    pub data: [u64, ..3u],
}
impl Union_Unnamed3 {
    pub fn heap(&mut self) -> *mut Struct_Unnamed4 {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn ary(&mut self) -> *mut [VALUE, ..3u] {
        unsafe { ::std::mem::transmute(self) }
    }
}
#[repr(C)]
pub struct Struct_Unnamed4 {
    pub numiv: ::libc::c_long,
    pub ivptr: *mut VALUE,
    pub iv_index_tbl: *mut Struct_st_table,
}
pub enum Struct_rb_classext_struct { }
pub type rb_classext_t = Struct_rb_classext_struct;
#[repr(C)]
pub struct Struct_RClass {
    pub basic: Struct_RBasic,
    pub _super: VALUE,
    pub ptr: *mut rb_classext_t,
    pub m_tbl_wrapper: *mut Struct_method_table_wrapper,
}
pub enum Struct_method_table_wrapper { }
#[repr(C)]
pub struct Struct_RFloat {
    pub basic: Struct_RBasic,
    pub float_value: ::libc::c_double,
}
#[repr(C)]
pub struct Struct_RString {
    pub basic: Struct_RBasic,
    pub _as: Union_Unnamed5,
}
#[repr(C)]
pub struct Union_Unnamed5 {
    pub data: [u64, ..3u],
}
impl Union_Unnamed5 {
    pub fn heap(&mut self) -> *mut Struct_Unnamed6 {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn ary(&mut self) -> *mut [::libc::c_char, ..24u] {
        unsafe { ::std::mem::transmute(self) }
    }
}
#[repr(C)]
pub struct Struct_Unnamed6 {
    pub len: ::libc::c_long,
    pub ptr: *mut ::libc::c_char,
    pub aux: Union_Unnamed7,
}
#[repr(C)]
pub struct Union_Unnamed7 {
    pub data: [u64, ..1u],
}
impl Union_Unnamed7 {
    pub fn capa(&mut self) -> *mut ::libc::c_long {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn shared(&mut self) -> *mut VALUE {
        unsafe { ::std::mem::transmute(self) }
    }
}
#[repr(C)]
pub struct Struct_RArray {
    pub basic: Struct_RBasic,
    pub _as: Union_Unnamed8,
}
#[repr(C)]
pub struct Union_Unnamed8 {
    pub data: [u64, ..3u],
}
impl Union_Unnamed8 {
    pub fn heap(&mut self) -> *mut Struct_Unnamed9 {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn ary(&mut self) -> *mut [VALUE, ..3u] {
        unsafe { ::std::mem::transmute(self) }
    }
}
#[repr(C)]
pub struct Struct_Unnamed9 {
    pub len: ::libc::c_long,
    pub aux: Union_Unnamed10,
    pub ptr: *const VALUE,
}
#[repr(C)]
pub struct Union_Unnamed10 {
    pub data: [u64, ..1u],
}
impl Union_Unnamed10 {
    pub fn capa(&mut self) -> *mut ::libc::c_long {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn shared(&mut self) -> *mut VALUE {
        unsafe { ::std::mem::transmute(self) }
    }
}
#[repr(C)]
pub struct Struct_RRegexp {
    pub basic: Struct_RBasic,
    pub ptr: *mut Struct_re_pattern_buffer,
    pub src: VALUE,
    pub usecnt: ::libc::c_ulong,
}
pub enum Struct_re_pattern_buffer { }
#[repr(C)]
pub struct Struct_RHash {
    pub basic: Struct_RBasic,
    pub ntbl: *mut Struct_st_table,
    pub iter_lev: ::libc::c_int,
    pub ifnone: VALUE,
}
#[repr(C)]
pub struct Struct_RFile {
    pub basic: Struct_RBasic,
    pub fptr: *mut Struct_rb_io_t,
}
pub enum Struct_rb_io_t { }
#[repr(C)]
pub struct Struct_RRational {
    pub basic: Struct_RBasic,
    pub num: VALUE,
    pub den: VALUE,
}
#[repr(C)]
pub struct Struct_RComplex {
    pub basic: Struct_RBasic,
    pub real: VALUE,
    pub imag: VALUE,
}
#[repr(C)]
pub struct Struct_RData {
    pub basic: Struct_RBasic,
    pub dmark: ::std::option::Option<extern "C" fn
                                         (arg1: *mut ::libc::c_void)>,
    pub dfree: ::std::option::Option<extern "C" fn
                                         (arg1: *mut ::libc::c_void)>,
    pub data: *mut ::libc::c_void,
}
pub type rb_data_type_t = Struct_rb_data_type_struct;
#[repr(C)]
pub struct Struct_rb_data_type_struct {
    pub wrap_struct_name: *const ::libc::c_char,
    pub function: Struct_Unnamed11,
    pub parent: *const rb_data_type_t,
    pub data: *mut ::libc::c_void,
    pub flags: VALUE,
}
#[repr(C)]
pub struct Struct_Unnamed11 {
    pub dmark: ::std::option::Option<extern "C" fn
                                         (arg1: *mut ::libc::c_void)>,
    pub dfree: ::std::option::Option<extern "C" fn
                                         (arg1: *mut ::libc::c_void)>,
    pub dsize: ::std::option::Option<extern "C" fn
                                         (arg1: *const ::libc::c_void)
                                         -> size_t>,
    pub reserved: [*mut ::libc::c_void, ..2u],
}
#[repr(C)]
pub struct Struct_RTypedData {
    pub basic: Struct_RBasic,
    pub _type: *const rb_data_type_t,
    pub typed_flag: VALUE,
    pub data: *mut ::libc::c_void,
}
pub type RUBY_DATA_FUNC =
    ::std::option::Option<extern "C" fn(arg1: *mut ::libc::c_void)>;
#[repr(C)]
pub struct Struct_RStruct {
    pub basic: Struct_RBasic,
    pub _as: Union_Unnamed12,
}
#[repr(C)]
pub struct Union_Unnamed12 {
    pub data: [u64, ..3u],
}
impl Union_Unnamed12 {
    pub fn heap(&mut self) -> *mut Struct_Unnamed13 {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn ary(&mut self) -> *mut [VALUE, ..3u] {
        unsafe { ::std::mem::transmute(self) }
    }
}
#[repr(C)]
pub struct Struct_Unnamed13 {
    pub len: ::libc::c_long,
    pub ptr: *const VALUE,
}
#[repr(C)]
pub struct Struct_RBignum {
    pub basic: Struct_RBasic,
    pub _as: Union_Unnamed14,
}
#[repr(C)]
pub struct Union_Unnamed14 {
    pub data: [u64, ..3u],
}
impl Union_Unnamed14 {
    pub fn heap(&mut self) -> *mut Struct_Unnamed15 {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn ary(&mut self) -> *mut [::libc::c_uint, ..6u] {
        unsafe { ::std::mem::transmute(self) }
    }
}
#[repr(C)]
pub struct Struct_Unnamed15 {
    pub len: ::libc::c_long,
    pub digits: *mut ::libc::c_uint,
}
pub type ruby_glob_func = ::libc::c_void;
pub enum Struct_rb_global_variable { }
pub type rb_gvar_getter_t = ::libc::c_void;
pub type rb_gvar_setter_t = ::libc::c_void;
pub type rb_gvar_marker_t = ::libc::c_void;
pub type rb_block_call_func = ::libc::c_void;
pub type rb_block_call_func_t =
    ::std::option::Option<extern "C" fn() -> VALUE>;
pub type st_data_t = ::libc::c_ulong;
pub type st_table = Struct_st_table;
pub type st_index_t = st_data_t;
pub type st_compare_func = ::libc::c_void;
pub type st_hash_func = ::libc::c_void;
pub type st_check_for_sizeof_st_index_t = [::libc::c_char, ..1u];
#[repr(C)]
pub struct Struct_st_hash_type {
    pub compare: ::std::option::Option<extern "C" fn() -> ::libc::c_int>,
    pub hash: ::std::option::Option<extern "C" fn() -> st_index_t>,
}
#[repr(C)]
pub struct Struct_st_table {
    pub _type: *const Struct_st_hash_type,
    pub num_bins: st_index_t,
    pub entries_packed: ::libc::c_uint,
    pub num_entries: st_index_t,
    pub _as: Union_Unnamed16,
}
#[repr(C)]
pub struct Union_Unnamed16 {
    pub data: [u64, ..3u],
}
impl Union_Unnamed16 {
    pub fn big(&mut self) -> *mut Struct_Unnamed17 {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn packed(&mut self) -> *mut Struct_Unnamed18 {
        unsafe { ::std::mem::transmute(self) }
    }
}
#[repr(C)]
pub struct Struct_Unnamed17 {
    pub bins: *mut *mut Struct_st_table_entry,
    pub head: *mut Struct_st_table_entry,
    pub tail: *mut Struct_st_table_entry,
}
pub enum Struct_st_table_entry { }
#[repr(C)]
pub struct Struct_Unnamed18 {
    pub entries: *mut Struct_st_packed_entry,
    pub real_entries: st_index_t,
}
pub enum Struct_st_packed_entry { }
pub type Enum_st_retval = ::libc::c_uint;
pub static ST_CONTINUE: ::libc::c_uint = 0;
pub static ST_STOP: ::libc::c_uint = 1;
pub static ST_DELETE: ::libc::c_uint = 2;
pub static ST_CHECK: ::libc::c_uint = 3;
pub type st_update_callback_func = ::libc::c_void;
pub type rb_enumerator_size_func = ::libc::c_void;
#[repr(C)]
pub struct rb_fdset_t {
    pub maxfd: ::libc::c_int,
    pub fdset: *mut fd_set,
}
pub type rb_alloc_func_t =
    ::std::option::Option<extern "C" fn(arg1: VALUE) -> VALUE>;
pub type rb_hash_update_func = ::libc::c_void;
#[repr(C)]
pub struct Struct_rb_exec_arg {
    pub execarg_obj: VALUE,
}
pub type rb_unblock_function_t = ::libc::c_void;
pub type rb_blocking_function_t = ::libc::c_void;
pub type rb_event_flag_t = ::libc::c_ulong;
pub type rb_event_hook_func_t =
    ::std::option::Option<extern "C" fn
                              (arg1: rb_event_flag_t, arg2: VALUE,
                               arg3: VALUE, arg4: ID, arg5: VALUE)>;
pub type __va_list_tag = Struct___va_list_tag;
#[repr(C)]
pub struct Struct___va_list_tag {
    pub gp_offset: ::libc::c_uint,
    pub fp_offset: ::libc::c_uint,
    pub overflow_arg_area: *mut ::libc::c_void,
    pub reg_save_area: *mut ::libc::c_void,
}
#[link(name = "ruby")]
extern "C" {
    pub static mut __stdinp: *mut FILE;
    pub static mut __stdoutp: *mut FILE;
    pub static mut __stderrp: *mut FILE;
    pub static sys_nerr: ::libc::c_int;
    pub static mut sys_errlist: *const *const ::libc::c_char;
    pub static mut __mb_cur_max: ::libc::c_int;
    pub static mut suboptarg: *mut ::libc::c_char;
    pub static mut optarg: *mut ::libc::c_char;
    pub static mut optind: ::libc::c_int;
    pub static mut opterr: ::libc::c_int;
    pub static mut optopt: ::libc::c_int;
    pub static mut optreset: ::libc::c_int;
    pub static mut signgam: ::libc::c_int;
    pub static mut rb_mKernel: VALUE;
    pub static mut rb_mComparable: VALUE;
    pub static mut rb_mEnumerable: VALUE;
    pub static mut rb_mErrno: VALUE;
    pub static mut rb_mFileTest: VALUE;
    pub static mut rb_mGC: VALUE;
    pub static mut rb_mMath: VALUE;
    pub static mut rb_mProcess: VALUE;
    pub static mut rb_mWaitReadable: VALUE;
    pub static mut rb_mWaitWritable: VALUE;
    pub static mut rb_cBasicObject: VALUE;
    pub static mut rb_cObject: VALUE;
    pub static mut rb_cArray: VALUE;
    pub static mut rb_cBignum: VALUE;
    pub static mut rb_cBinding: VALUE;
    pub static mut rb_cClass: VALUE;
    pub static mut rb_cCont: VALUE;
    pub static mut rb_cDir: VALUE;
    pub static mut rb_cData: VALUE;
    pub static mut rb_cFalseClass: VALUE;
    pub static mut rb_cEncoding: VALUE;
    pub static mut rb_cEnumerator: VALUE;
    pub static mut rb_cFile: VALUE;
    pub static mut rb_cFixnum: VALUE;
    pub static mut rb_cFloat: VALUE;
    pub static mut rb_cHash: VALUE;
    pub static mut rb_cInteger: VALUE;
    pub static mut rb_cIO: VALUE;
    pub static mut rb_cMatch: VALUE;
    pub static mut rb_cMethod: VALUE;
    pub static mut rb_cModule: VALUE;
    pub static mut rb_cNameErrorMesg: VALUE;
    pub static mut rb_cNilClass: VALUE;
    pub static mut rb_cNumeric: VALUE;
    pub static mut rb_cProc: VALUE;
    pub static mut rb_cRandom: VALUE;
    pub static mut rb_cRange: VALUE;
    pub static mut rb_cRational: VALUE;
    pub static mut rb_cComplex: VALUE;
    pub static mut rb_cRegexp: VALUE;
    pub static mut rb_cStat: VALUE;
    pub static mut rb_cString: VALUE;
    pub static mut rb_cStruct: VALUE;
    pub static mut rb_cSymbol: VALUE;
    pub static mut rb_cThread: VALUE;
    pub static mut rb_cTime: VALUE;
    pub static mut rb_cTrueClass: VALUE;
    pub static mut rb_cUnboundMethod: VALUE;
    pub static mut rb_eException: VALUE;
    pub static mut rb_eStandardError: VALUE;
    pub static mut rb_eSystemExit: VALUE;
    pub static mut rb_eInterrupt: VALUE;
    pub static mut rb_eSignal: VALUE;
    pub static mut rb_eFatal: VALUE;
    pub static mut rb_eArgError: VALUE;
    pub static mut rb_eEOFError: VALUE;
    pub static mut rb_eIndexError: VALUE;
    pub static mut rb_eStopIteration: VALUE;
    pub static mut rb_eKeyError: VALUE;
    pub static mut rb_eRangeError: VALUE;
    pub static mut rb_eIOError: VALUE;
    pub static mut rb_eRuntimeError: VALUE;
    pub static mut rb_eSecurityError: VALUE;
    pub static mut rb_eSystemCallError: VALUE;
    pub static mut rb_eThreadError: VALUE;
    pub static mut rb_eTypeError: VALUE;
    pub static mut rb_eZeroDivError: VALUE;
    pub static mut rb_eNotImpError: VALUE;
    pub static mut rb_eNoMemError: VALUE;
    pub static mut rb_eNoMethodError: VALUE;
    pub static mut rb_eFloatDomainError: VALUE;
    pub static mut rb_eLocalJumpError: VALUE;
    pub static mut rb_eSysStackError: VALUE;
    pub static mut rb_eRegexpError: VALUE;
    pub static mut rb_eEncodingError: VALUE;
    pub static mut rb_eEncCompatError: VALUE;
    pub static mut rb_eScriptError: VALUE;
    pub static mut rb_eNameError: VALUE;
    pub static mut rb_eSyntaxError: VALUE;
    pub static mut rb_eLoadError: VALUE;
    pub static mut rb_eMathDomainError: VALUE;
    pub static mut rb_stdin: VALUE;
    pub static mut rb_stdout: VALUE;
    pub static mut rb_stderr: VALUE;
    pub static mut rb_fs: VALUE;
    pub static mut rb_output_fs: VALUE;
    pub static mut rb_rs: VALUE;
    pub static mut rb_default_rs: VALUE;
    pub static mut rb_output_rs: VALUE;
    pub static mut ruby_sourceline: ::libc::c_int;
    pub static mut ruby_sourcefile: *mut ::libc::c_char;
    pub static mut rb_argv0: VALUE;
    pub fn renameat(arg1: ::libc::c_int, arg2: *const ::libc::c_char,
                    arg3: ::libc::c_int, arg4: *const ::libc::c_char) ->
     ::libc::c_int;
    pub fn clearerr(arg1: *mut FILE);
    pub fn fclose(arg1: *mut FILE) -> ::libc::c_int;
    pub fn feof(arg1: *mut FILE) -> ::libc::c_int;
    pub fn ferror(arg1: *mut FILE) -> ::libc::c_int;
    pub fn fflush(arg1: *mut FILE) -> ::libc::c_int;
    pub fn fgetc(arg1: *mut FILE) -> ::libc::c_int;
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::libc::c_int;
    pub fn fgets(arg1: *mut ::libc::c_char, arg2: ::libc::c_int,
                 arg3: *mut FILE) -> *mut ::libc::c_char;
    pub fn fopen(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) ->
     *mut FILE;
    pub fn fprintf(arg1: *mut FILE, arg2: *const ::libc::c_char, ...) ->
     ::libc::c_int;
    pub fn fputc(arg1: ::libc::c_int, arg2: *mut FILE) -> ::libc::c_int;
    pub fn fputs(arg1: *const ::libc::c_char, arg2: *mut FILE) ->
     ::libc::c_int;
    pub fn fread(arg1: *mut ::libc::c_void, arg2: size_t, arg3: size_t,
                 arg4: *mut FILE) -> size_t;
    pub fn freopen(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: *mut FILE) -> *mut FILE;
    pub fn fscanf(arg1: *mut FILE, arg2: *const ::libc::c_char, ...) ->
     ::libc::c_int;
    pub fn fseek(arg1: *mut FILE, arg2: ::libc::c_long, arg3: ::libc::c_int)
     -> ::libc::c_int;
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::libc::c_int;
    pub fn ftell(arg1: *mut FILE) -> ::libc::c_long;
    pub fn fwrite(arg1: *const ::libc::c_void, arg2: size_t, arg3: size_t,
                  arg4: *mut FILE) -> size_t;
    pub fn getc(arg1: *mut FILE) -> ::libc::c_int;
    pub fn getchar() -> ::libc::c_int;
    pub fn gets(arg1: *mut ::libc::c_char) -> *mut ::libc::c_char;
    pub fn perror(arg1: *const ::libc::c_char);
    pub fn printf(arg1: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn putc(arg1: ::libc::c_int, arg2: *mut FILE) -> ::libc::c_int;
    pub fn putchar(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn puts(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn remove(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn rename(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) ->
     ::libc::c_int;
    pub fn rewind(arg1: *mut FILE);
    pub fn scanf(arg1: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::libc::c_char);
    pub fn setvbuf(arg1: *mut FILE, arg2: *mut ::libc::c_char,
                   arg3: ::libc::c_int, arg4: size_t) -> ::libc::c_int;
    pub fn sprintf(arg1: *mut ::libc::c_char,
                   arg2: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn sscanf(arg1: *const ::libc::c_char,
                  arg2: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn tmpfile() -> *mut FILE;
    pub fn tmpnam(arg1: *mut ::libc::c_char) -> *mut ::libc::c_char;
    pub fn ungetc(arg1: ::libc::c_int, arg2: *mut FILE) -> ::libc::c_int;
    pub fn vfprintf(arg1: *mut FILE, arg2: *const ::libc::c_char,
                    arg3: va_list) -> ::libc::c_int;
    pub fn vprintf(arg1: *const ::libc::c_char, arg2: va_list) ->
     ::libc::c_int;
    pub fn vsprintf(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                    arg3: va_list) -> ::libc::c_int;
    pub fn ctermid(arg1: *mut ::libc::c_char) -> *mut ::libc::c_char;
    pub fn fdopen(arg1: ::libc::c_int, arg2: *const ::libc::c_char) ->
     *mut FILE;
    pub fn fileno(arg1: *mut FILE) -> ::libc::c_int;
    pub fn pclose(arg1: *mut FILE) -> ::libc::c_int;
    pub fn popen(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) ->
     *mut FILE;
    pub fn __srget(arg1: *mut FILE) -> ::libc::c_int;
    pub fn __svfscanf(arg1: *mut FILE, arg2: *const ::libc::c_char,
                      arg3: va_list) -> ::libc::c_int;
    pub fn __swbuf(arg1: ::libc::c_int, arg2: *mut FILE) -> ::libc::c_int;
    pub fn __sputc(_c: ::libc::c_int, _p: *mut FILE) -> ::libc::c_int;
    pub fn flockfile(arg1: *mut FILE);
    pub fn ftrylockfile(arg1: *mut FILE) -> ::libc::c_int;
    pub fn funlockfile(arg1: *mut FILE);
    pub fn getc_unlocked(arg1: *mut FILE) -> ::libc::c_int;
    pub fn getchar_unlocked() -> ::libc::c_int;
    pub fn putc_unlocked(arg1: ::libc::c_int, arg2: *mut FILE) ->
     ::libc::c_int;
    pub fn putchar_unlocked(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn getw(arg1: *mut FILE) -> ::libc::c_int;
    pub fn putw(arg1: ::libc::c_int, arg2: *mut FILE) -> ::libc::c_int;
    pub fn tempnam(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: ::libc::c_int) ->
     ::libc::c_int;
    pub fn ftello(arg1: *mut FILE) -> off_t;
    pub fn snprintf(arg1: *mut ::libc::c_char, arg2: size_t,
                    arg3: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn vfscanf(arg1: *mut FILE, arg2: *const ::libc::c_char,
                   arg3: va_list) -> ::libc::c_int;
    pub fn vscanf(arg1: *const ::libc::c_char, arg2: va_list) ->
     ::libc::c_int;
    pub fn vsnprintf(arg1: *mut ::libc::c_char, arg2: size_t,
                     arg3: *const ::libc::c_char, arg4: va_list) ->
     ::libc::c_int;
    pub fn vsscanf(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: va_list) -> ::libc::c_int;
    pub fn dprintf(arg1: ::libc::c_int, arg2: *const ::libc::c_char, ...) ->
     ::libc::c_int;
    pub fn vdprintf(arg1: ::libc::c_int, arg2: *const ::libc::c_char,
                    arg3: va_list) -> ::libc::c_int;
    pub fn getdelim(arg1: *mut *mut ::libc::c_char, arg2: *mut size_t,
                    arg3: ::libc::c_int, arg4: *mut FILE) -> ssize_t;
    pub fn getline(arg1: *mut *mut ::libc::c_char, arg2: *mut size_t,
                   arg3: *mut FILE) -> ssize_t;
    pub fn asprintf(arg1: *mut *mut ::libc::c_char,
                    arg2: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn ctermid_r(arg1: *mut ::libc::c_char) -> *mut ::libc::c_char;
    pub fn fgetln(arg1: *mut FILE, arg2: *mut size_t) -> *mut ::libc::c_char;
    pub fn fmtcheck(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char)
     -> *const ::libc::c_char;
    pub fn fpurge(arg1: *mut FILE) -> ::libc::c_int;
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut ::libc::c_char,
                     arg3: ::libc::c_int);
    pub fn setlinebuf(arg1: *mut FILE) -> ::libc::c_int;
    pub fn vasprintf(arg1: *mut *mut ::libc::c_char,
                     arg2: *const ::libc::c_char, arg3: va_list) ->
     ::libc::c_int;
    pub fn zopen(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char,
                 arg3: ::libc::c_int) -> *mut FILE;
    pub fn funopen(arg1: *const ::libc::c_void,
                   arg2:
                       ::std::option::Option<extern "C" fn
                                                 (arg1: *mut ::libc::c_void,
                                                  arg2: *mut ::libc::c_char,
                                                  arg3: ::libc::c_int)
                                                 -> ::libc::c_int>,
                   arg3:
                       ::std::option::Option<extern "C" fn
                                                 (arg1: *mut ::libc::c_void,
                                                  arg2: *const ::libc::c_char,
                                                  arg3: ::libc::c_int)
                                                 -> ::libc::c_int>,
                   arg4:
                       ::std::option::Option<extern "C" fn
                                                 (arg1: *mut ::libc::c_void,
                                                  arg2: fpos_t,
                                                  arg3: ::libc::c_int)
                                                 -> fpos_t>,
                   arg5:
                       ::std::option::Option<extern "C" fn
                                                 (arg1: *mut ::libc::c_void)
                                                 -> ::libc::c_int>) ->
     *mut FILE;
    pub fn __sprintf_chk(arg1: *mut ::libc::c_char, arg2: ::libc::c_int,
                         arg3: size_t, arg4: *const ::libc::c_char, ...) ->
     ::libc::c_int;
    pub fn __snprintf_chk(arg1: *mut ::libc::c_char, arg2: size_t,
                          arg3: ::libc::c_int, arg4: size_t,
                          arg5: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn __vsprintf_chk(arg1: *mut ::libc::c_char, arg2: ::libc::c_int,
                          arg3: size_t, arg4: *const ::libc::c_char,
                          arg5: va_list) -> ::libc::c_int;
    pub fn __vsnprintf_chk(arg1: *mut ::libc::c_char, arg2: size_t,
                           arg3: ::libc::c_int, arg4: size_t,
                           arg5: *const ::libc::c_char, arg6: va_list) ->
     ::libc::c_int;
    pub fn chmod(arg1: *const ::libc::c_char, arg2: mode_t) -> ::libc::c_int;
    pub fn fchmod(arg1: ::libc::c_int, arg2: mode_t) -> ::libc::c_int;
    pub fn fstat(arg1: ::libc::c_int, arg2: *mut Struct_stat) ->
     ::libc::c_int;
    pub fn lstat(arg1: *const ::libc::c_char, arg2: *mut Struct_stat) ->
     ::libc::c_int;
    pub fn mkdir(arg1: *const ::libc::c_char, arg2: mode_t) -> ::libc::c_int;
    pub fn mkfifo(arg1: *const ::libc::c_char, arg2: mode_t) -> ::libc::c_int;
    pub fn stat(arg1: *const ::libc::c_char, arg2: *mut Struct_stat) ->
     ::libc::c_int;
    pub fn mknod(arg1: *const ::libc::c_char, arg2: mode_t, arg3: dev_t) ->
     ::libc::c_int;
    pub fn umask(arg1: mode_t) -> mode_t;
    pub fn fchmodat(arg1: ::libc::c_int, arg2: *const ::libc::c_char,
                    arg3: mode_t, arg4: ::libc::c_int) -> ::libc::c_int;
    pub fn fstatat(arg1: ::libc::c_int, arg2: *const ::libc::c_char,
                   arg3: *mut Struct_stat, arg4: ::libc::c_int) ->
     ::libc::c_int;
    pub fn mkdirat(arg1: ::libc::c_int, arg2: *const ::libc::c_char,
                   arg3: mode_t) -> ::libc::c_int;
    pub fn chflags(arg1: *const ::libc::c_char, arg2: __uint32_t) ->
     ::libc::c_int;
    pub fn chmodx_np(arg1: *const ::libc::c_char, arg2: filesec_t) ->
     ::libc::c_int;
    pub fn fchflags(arg1: ::libc::c_int, arg2: __uint32_t) -> ::libc::c_int;
    pub fn fchmodx_np(arg1: ::libc::c_int, arg2: filesec_t) -> ::libc::c_int;
    pub fn fstatx_np(arg1: ::libc::c_int, arg2: *mut Struct_stat,
                     arg3: filesec_t) -> ::libc::c_int;
    pub fn lchflags(arg1: *const ::libc::c_char, arg2: __uint32_t) ->
     ::libc::c_int;
    pub fn lchmod(arg1: *const ::libc::c_char, arg2: mode_t) -> ::libc::c_int;
    pub fn lstatx_np(arg1: *const ::libc::c_char, arg2: *mut Struct_stat,
                     arg3: filesec_t) -> ::libc::c_int;
    pub fn mkdirx_np(arg1: *const ::libc::c_char, arg2: filesec_t) ->
     ::libc::c_int;
    pub fn mkfifox_np(arg1: *const ::libc::c_char, arg2: filesec_t) ->
     ::libc::c_int;
    pub fn statx_np(arg1: *const ::libc::c_char, arg2: *mut Struct_stat,
                    arg3: filesec_t) -> ::libc::c_int;
    pub fn umaskx_np(arg1: filesec_t) -> ::libc::c_int;
    pub fn fstatx64_np(arg1: ::libc::c_int, arg2: *mut Struct_stat64,
                       arg3: filesec_t) -> ::libc::c_int;
    pub fn lstatx64_np(arg1: *const ::libc::c_char, arg2: *mut Struct_stat64,
                       arg3: filesec_t) -> ::libc::c_int;
    pub fn statx64_np(arg1: *const ::libc::c_char, arg2: *mut Struct_stat64,
                      arg3: filesec_t) -> ::libc::c_int;
    pub fn fstat64(arg1: ::libc::c_int, arg2: *mut Struct_stat64) ->
     ::libc::c_int;
    pub fn lstat64(arg1: *const ::libc::c_char, arg2: *mut Struct_stat64) ->
     ::libc::c_int;
    pub fn stat64(arg1: *const ::libc::c_char, arg2: *mut Struct_stat64) ->
     ::libc::c_int;
    pub fn signal(arg1: ::libc::c_int,
                  arg2:
                      ::std::option::Option<extern "C" fn
                                                (arg1: ::libc::c_int)>) ->
     ::std::option::Option<extern "C" fn(arg1: ::libc::c_int)>;
    pub fn getpriority(arg1: ::libc::c_int, arg2: id_t) -> ::libc::c_int;
    pub fn getiopolicy_np(arg1: ::libc::c_int, arg2: ::libc::c_int) ->
     ::libc::c_int;
    pub fn getrlimit(arg1: ::libc::c_int, arg2: *mut Struct_rlimit) ->
     ::libc::c_int;
    pub fn getrusage(arg1: ::libc::c_int, arg2: *mut Struct_rusage) ->
     ::libc::c_int;
    pub fn setpriority(arg1: ::libc::c_int, arg2: id_t, arg3: ::libc::c_int)
     -> ::libc::c_int;
    pub fn setiopolicy_np(arg1: ::libc::c_int, arg2: ::libc::c_int,
                          arg3: ::libc::c_int) -> ::libc::c_int;
    pub fn setrlimit(arg1: ::libc::c_int, arg2: *const Struct_rlimit) ->
     ::libc::c_int;
    pub fn wait(arg1: *mut ::libc::c_int) -> pid_t;
    pub fn waitpid(arg1: pid_t, arg2: *mut ::libc::c_int, arg3: ::libc::c_int)
     -> pid_t;
    pub fn waitid(arg1: idtype_t, arg2: id_t, arg3: *mut siginfo_t,
                  arg4: ::libc::c_int) -> ::libc::c_int;
    pub fn wait3(arg1: *mut ::libc::c_int, arg2: ::libc::c_int,
                 arg3: *mut Struct_rusage) -> pid_t;
    pub fn wait4(arg1: pid_t, arg2: *mut ::libc::c_int, arg3: ::libc::c_int,
                 arg4: *mut Struct_rusage) -> pid_t;
    pub fn alloca(arg1: size_t) -> *mut ::libc::c_void;
    pub fn abort();
    pub fn abs(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn atexit(arg1: ::std::option::Option<extern "C" fn()>) ->
     ::libc::c_int;
    pub fn atof(arg1: *const ::libc::c_char) -> ::libc::c_double;
    pub fn atoi(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn atol(arg1: *const ::libc::c_char) -> ::libc::c_long;
    pub fn atoll(arg1: *const ::libc::c_char) -> ::libc::c_longlong;
    pub fn bsearch(arg1: *const ::libc::c_void, arg2: *const ::libc::c_void,
                   arg3: size_t, arg4: size_t,
                   arg5:
                       ::std::option::Option<extern "C" fn
                                                 (arg1: *const ::libc::c_void,
                                                  arg2: *const ::libc::c_void)
                                                 -> ::libc::c_int>) ->
     *mut ::libc::c_void;
    pub fn calloc(arg1: size_t, arg2: size_t) -> *mut ::libc::c_void;
    pub fn div(arg1: ::libc::c_int, arg2: ::libc::c_int) -> div_t;
    pub fn exit(arg1: ::libc::c_int);
    pub fn free(arg1: *mut ::libc::c_void);
    pub fn getenv(arg1: *const ::libc::c_char) -> *mut ::libc::c_char;
    pub fn labs(arg1: ::libc::c_long) -> ::libc::c_long;
    pub fn ldiv(arg1: ::libc::c_long, arg2: ::libc::c_long) -> ldiv_t;
    pub fn llabs(arg1: ::libc::c_longlong) -> ::libc::c_longlong;
    pub fn lldiv(arg1: ::libc::c_longlong, arg2: ::libc::c_longlong) ->
     lldiv_t;
    pub fn malloc(arg1: size_t) -> *mut ::libc::c_void;
    pub fn mblen(arg1: *const ::libc::c_char, arg2: size_t) -> ::libc::c_int;
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::libc::c_char,
                    arg3: size_t) -> size_t;
    pub fn mbtowc(arg1: *mut wchar_t, arg2: *const ::libc::c_char,
                  arg3: size_t) -> ::libc::c_int;
    pub fn posix_memalign(arg1: *mut *mut ::libc::c_void, arg2: size_t,
                          arg3: size_t) -> ::libc::c_int;
    pub fn qsort(arg1: *mut ::libc::c_void, arg2: size_t, arg3: size_t,
                 arg4:
                     ::std::option::Option<extern "C" fn
                                               (arg1: *const ::libc::c_void,
                                                arg2: *const ::libc::c_void)
                                               -> ::libc::c_int>);
    pub fn rand() -> ::libc::c_int;
    pub fn realloc(arg1: *mut ::libc::c_void, arg2: size_t) ->
     *mut ::libc::c_void;
    pub fn srand(arg1: ::libc::c_uint);
    pub fn strtod(arg1: *const ::libc::c_char, arg2: *mut *mut ::libc::c_char)
     -> ::libc::c_double;
    pub fn strtof(arg1: *const ::libc::c_char, arg2: *mut *mut ::libc::c_char)
     -> ::libc::c_float;
    pub fn strtol(arg1: *const ::libc::c_char, arg2: *mut *mut ::libc::c_char,
                  arg3: ::libc::c_int) -> ::libc::c_long;
    pub fn strtold(arg1: *const ::libc::c_char,
                   arg2: *mut *mut ::libc::c_char) -> ::libc::c_double;
    pub fn strtoll(arg1: *const ::libc::c_char,
                   arg2: *mut *mut ::libc::c_char, arg3: ::libc::c_int) ->
     ::libc::c_longlong;
    pub fn strtoul(arg1: *const ::libc::c_char,
                   arg2: *mut *mut ::libc::c_char, arg3: ::libc::c_int) ->
     ::libc::c_ulong;
    pub fn strtoull(arg1: *const ::libc::c_char,
                    arg2: *mut *mut ::libc::c_char, arg3: ::libc::c_int) ->
     ::libc::c_ulonglong;
    pub fn system(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn wcstombs(arg1: *mut ::libc::c_char, arg2: *const wchar_t,
                    arg3: size_t) -> size_t;
    pub fn wctomb(arg1: *mut ::libc::c_char, arg2: wchar_t) -> ::libc::c_int;
    pub fn _Exit(arg1: ::libc::c_int);
    pub fn a64l(arg1: *const ::libc::c_char) -> ::libc::c_long;
    pub fn drand48() -> ::libc::c_double;
    pub fn ecvt(arg1: ::libc::c_double, arg2: ::libc::c_int,
                arg3: *mut ::libc::c_int, arg4: *mut ::libc::c_int) ->
     *mut ::libc::c_char;
    pub fn erand48(arg1: [::libc::c_ushort, ..3u]) -> ::libc::c_double;
    pub fn fcvt(arg1: ::libc::c_double, arg2: ::libc::c_int,
                arg3: *mut ::libc::c_int, arg4: *mut ::libc::c_int) ->
     *mut ::libc::c_char;
    pub fn gcvt(arg1: ::libc::c_double, arg2: ::libc::c_int,
                arg3: *mut ::libc::c_char) -> *mut ::libc::c_char;
    pub fn getsubopt(arg1: *mut *mut ::libc::c_char,
                     arg2: *const *mut ::libc::c_char,
                     arg3: *mut *mut ::libc::c_char) -> ::libc::c_int;
    pub fn grantpt(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn initstate(arg1: ::libc::c_uint, arg2: *mut ::libc::c_char,
                     arg3: size_t) -> *mut ::libc::c_char;
    pub fn jrand48(arg1: [::libc::c_ushort, ..3u]) -> ::libc::c_long;
    pub fn l64a(arg1: ::libc::c_long) -> *mut ::libc::c_char;
    pub fn lcong48(arg1: [::libc::c_ushort, ..7u]);
    pub fn lrand48() -> ::libc::c_long;
    pub fn mktemp(arg1: *mut ::libc::c_char) -> *mut ::libc::c_char;
    pub fn mkstemp(arg1: *mut ::libc::c_char) -> ::libc::c_int;
    pub fn mrand48() -> ::libc::c_long;
    pub fn nrand48(arg1: [::libc::c_ushort, ..3u]) -> ::libc::c_long;
    pub fn posix_openpt(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn ptsname(arg1: ::libc::c_int) -> *mut ::libc::c_char;
    pub fn putenv(arg1: *mut ::libc::c_char) -> ::libc::c_int;
    pub fn random() -> ::libc::c_long;
    pub fn rand_r(arg1: *mut ::libc::c_uint) -> ::libc::c_int;
    pub fn realpath(arg1: *const ::libc::c_char, arg2: *mut ::libc::c_char) ->
     *mut ::libc::c_char;
    pub fn seed48(arg1: [::libc::c_ushort, ..3u]) -> *mut ::libc::c_ushort;
    pub fn setenv(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char,
                  arg3: ::libc::c_int) -> ::libc::c_int;
    pub fn setkey(arg1: *const ::libc::c_char);
    pub fn setstate(arg1: *const ::libc::c_char) -> *mut ::libc::c_char;
    pub fn srand48(arg1: ::libc::c_long);
    pub fn srandom(arg1: ::libc::c_uint);
    pub fn unlockpt(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn unsetenv(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn arc4random() -> u_int32_t;
    pub fn arc4random_addrandom(arg1: *mut ::libc::c_uchar,
                                arg2: ::libc::c_int);
    pub fn arc4random_buf(arg1: *mut ::libc::c_void, arg2: size_t);
    pub fn arc4random_stir();
    pub fn arc4random_uniform(arg1: u_int32_t) -> u_int32_t;
    pub fn atexit_b(arg1: ::libc::c_void) -> ::libc::c_int;
    pub fn bsearch_b(arg1: *const ::libc::c_void, arg2: *const ::libc::c_void,
                     arg3: size_t, arg4: size_t, arg5: ::libc::c_void) ->
     *mut ::libc::c_void;
    pub fn cgetcap(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: ::libc::c_int) -> *mut ::libc::c_char;
    pub fn cgetclose() -> ::libc::c_int;
    pub fn cgetent(arg1: *mut *mut ::libc::c_char,
                   arg2: *mut *mut ::libc::c_char,
                   arg3: *const ::libc::c_char) -> ::libc::c_int;
    pub fn cgetfirst(arg1: *mut *mut ::libc::c_char,
                     arg2: *mut *mut ::libc::c_char) -> ::libc::c_int;
    pub fn cgetmatch(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn cgetnext(arg1: *mut *mut ::libc::c_char,
                    arg2: *mut *mut ::libc::c_char) -> ::libc::c_int;
    pub fn cgetnum(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: *mut ::libc::c_long) -> ::libc::c_int;
    pub fn cgetset(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn cgetstr(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: *mut *mut ::libc::c_char) -> ::libc::c_int;
    pub fn cgetustr(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                    arg3: *mut *mut ::libc::c_char) -> ::libc::c_int;
    pub fn daemon(arg1: ::libc::c_int, arg2: ::libc::c_int) -> ::libc::c_int;
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::libc::c_char;
    pub fn devname_r(arg1: dev_t, arg2: mode_t, buf: *mut ::libc::c_char,
                     len: ::libc::c_int) -> *mut ::libc::c_char;
    pub fn getbsize(arg1: *mut ::libc::c_int, arg2: *mut ::libc::c_long) ->
     *mut ::libc::c_char;
    pub fn getloadavg(arg1: *mut ::libc::c_double, arg2: ::libc::c_int) ->
     ::libc::c_int;
    pub fn getprogname() -> *const ::libc::c_char;
    pub fn heapsort(arg1: *mut ::libc::c_void, arg2: size_t, arg3: size_t,
                    arg4:
                        ::std::option::Option<extern "C" fn
                                                  (arg1:
                                                       *const ::libc::c_void,
                                                   arg2:
                                                       *const ::libc::c_void)
                                                  -> ::libc::c_int>) ->
     ::libc::c_int;
    pub fn heapsort_b(arg1: *mut ::libc::c_void, arg2: size_t, arg3: size_t,
                      arg4: ::libc::c_void) -> ::libc::c_int;
    pub fn mergesort(arg1: *mut ::libc::c_void, arg2: size_t, arg3: size_t,
                     arg4:
                         ::std::option::Option<extern "C" fn
                                                   (arg1:
                                                        *const ::libc::c_void,
                                                    arg2:
                                                        *const ::libc::c_void)
                                                   -> ::libc::c_int>) ->
     ::libc::c_int;
    pub fn mergesort_b(arg1: *mut ::libc::c_void, arg2: size_t, arg3: size_t,
                       arg4: ::libc::c_void) -> ::libc::c_int;
    pub fn psort(arg1: *mut ::libc::c_void, arg2: size_t, arg3: size_t,
                 arg4:
                     ::std::option::Option<extern "C" fn
                                               (arg1: *const ::libc::c_void,
                                                arg2: *const ::libc::c_void)
                                               -> ::libc::c_int>);
    pub fn psort_b(arg1: *mut ::libc::c_void, arg2: size_t, arg3: size_t,
                   arg4: ::libc::c_void);
    pub fn psort_r(arg1: *mut ::libc::c_void, arg2: size_t, arg3: size_t,
                   arg4: *mut ::libc::c_void,
                   arg5:
                       ::std::option::Option<extern "C" fn
                                                 (arg1: *mut ::libc::c_void,
                                                  arg2: *const ::libc::c_void,
                                                  arg3: *const ::libc::c_void)
                                                 -> ::libc::c_int>);
    pub fn qsort_b(arg1: *mut ::libc::c_void, arg2: size_t, arg3: size_t,
                   arg4: ::libc::c_void);
    pub fn qsort_r(arg1: *mut ::libc::c_void, arg2: size_t, arg3: size_t,
                   arg4: *mut ::libc::c_void,
                   arg5:
                       ::std::option::Option<extern "C" fn
                                                 (arg1: *mut ::libc::c_void,
                                                  arg2: *const ::libc::c_void,
                                                  arg3: *const ::libc::c_void)
                                                 -> ::libc::c_int>);
    pub fn radixsort(arg1: *mut *const ::libc::c_uchar, arg2: ::libc::c_int,
                     arg3: *const ::libc::c_uchar, arg4: ::libc::c_uint) ->
     ::libc::c_int;
    pub fn setprogname(arg1: *const ::libc::c_char);
    pub fn sradixsort(arg1: *mut *const ::libc::c_uchar, arg2: ::libc::c_int,
                      arg3: *const ::libc::c_uchar, arg4: ::libc::c_uint) ->
     ::libc::c_int;
    pub fn sranddev();
    pub fn srandomdev();
    pub fn reallocf(arg1: *mut ::libc::c_void, arg2: size_t) ->
     *mut ::libc::c_void;
    pub fn strtoq(arg1: *const ::libc::c_char, arg2: *mut *mut ::libc::c_char,
                  arg3: ::libc::c_int) -> ::libc::c_longlong;
    pub fn strtouq(arg1: *const ::libc::c_char,
                   arg2: *mut *mut ::libc::c_char, arg3: ::libc::c_int) ->
     ::libc::c_ulonglong;
    pub fn valloc(arg1: size_t) -> *mut ::libc::c_void;
    pub fn memchr(arg1: *const ::libc::c_void, arg2: ::libc::c_int,
                  arg3: size_t) -> *mut ::libc::c_void;
    pub fn memcmp(arg1: *const ::libc::c_void, arg2: *const ::libc::c_void,
                  arg3: size_t) -> ::libc::c_int;
    pub fn memcpy(arg1: *mut ::libc::c_void, arg2: *const ::libc::c_void,
                  arg3: size_t) -> *mut ::libc::c_void;
    pub fn memmove(arg1: *mut ::libc::c_void, arg2: *const ::libc::c_void,
                   arg3: size_t) -> *mut ::libc::c_void;
    pub fn memset(arg1: *mut ::libc::c_void, arg2: ::libc::c_int,
                  arg3: size_t) -> *mut ::libc::c_void;
    pub fn strcat(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char) ->
     *mut ::libc::c_char;
    pub fn strchr(arg1: *const ::libc::c_char, arg2: ::libc::c_int) ->
     *mut ::libc::c_char;
    pub fn strcmp(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) ->
     ::libc::c_int;
    pub fn strcoll(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn strcpy(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char) ->
     *mut ::libc::c_char;
    pub fn strcspn(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char)
     -> size_t;
    pub fn strerror(arg1: ::libc::c_int) -> *mut ::libc::c_char;
    pub fn strlen(arg1: *const ::libc::c_char) -> size_t;
    pub fn strncat(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: size_t) -> *mut ::libc::c_char;
    pub fn strncmp(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: size_t) -> ::libc::c_int;
    pub fn strncpy(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: size_t) -> *mut ::libc::c_char;
    pub fn strpbrk(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn strrchr(arg1: *const ::libc::c_char, arg2: ::libc::c_int) ->
     *mut ::libc::c_char;
    pub fn strspn(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) ->
     size_t;
    pub fn strstr(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) ->
     *mut ::libc::c_char;
    pub fn strtok(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char) ->
     *mut ::libc::c_char;
    pub fn strxfrm(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: size_t) -> size_t;
    pub fn strtok_r(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                    arg3: *mut *mut ::libc::c_char) -> *mut ::libc::c_char;
    pub fn strerror_r(arg1: ::libc::c_int, arg2: *mut ::libc::c_char,
                      arg3: size_t) -> ::libc::c_int;
    pub fn strdup(arg1: *const ::libc::c_char) -> *mut ::libc::c_char;
    pub fn memccpy(arg1: *mut ::libc::c_void, arg2: *const ::libc::c_void,
                   arg3: ::libc::c_int, arg4: size_t) -> *mut ::libc::c_void;
    pub fn stpcpy(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char) ->
     *mut ::libc::c_char;
    pub fn stpncpy(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: size_t) -> *mut ::libc::c_char;
    pub fn strndup(arg1: *const ::libc::c_char, arg2: size_t) ->
     *mut ::libc::c_char;
    pub fn strnlen(arg1: *const ::libc::c_char, arg2: size_t) -> size_t;
    pub fn strsignal(sig: ::libc::c_int) -> *mut ::libc::c_char;
    pub fn memset_s(arg1: *mut ::libc::c_void, arg2: rsize_t,
                    arg3: ::libc::c_int, arg4: rsize_t) -> errno_t;
    pub fn memmem(arg1: *const ::libc::c_void, arg2: size_t,
                  arg3: *const ::libc::c_void, arg4: size_t) ->
     *mut ::libc::c_void;
    pub fn memset_pattern4(arg1: *mut ::libc::c_void,
                           arg2: *const ::libc::c_void, arg3: size_t);
    pub fn memset_pattern8(arg1: *mut ::libc::c_void,
                           arg2: *const ::libc::c_void, arg3: size_t);
    pub fn memset_pattern16(arg1: *mut ::libc::c_void,
                            arg2: *const ::libc::c_void, arg3: size_t);
    pub fn strcasestr(arg1: *const ::libc::c_char,
                      arg2: *const ::libc::c_char) -> *mut ::libc::c_char;
    pub fn strnstr(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: size_t) -> *mut ::libc::c_char;
    pub fn strlcat(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: size_t) -> size_t;
    pub fn strlcpy(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: size_t) -> size_t;
    pub fn strmode(arg1: ::libc::c_int, arg2: *mut ::libc::c_char);
    pub fn strsep(arg1: *mut *mut ::libc::c_char, arg2: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn swab(arg1: *const ::libc::c_void, arg2: *mut ::libc::c_void,
                arg3: ssize_t);
    pub fn bcmp(arg1: *const ::libc::c_void, arg2: *const ::libc::c_void,
                arg3: size_t) -> ::libc::c_int;
    pub fn bcopy(arg1: *const ::libc::c_void, arg2: *mut ::libc::c_void,
                 arg3: size_t);
    pub fn bzero(arg1: *mut ::libc::c_void, arg2: size_t);
    pub fn index(arg1: *const ::libc::c_char, arg2: ::libc::c_int) ->
     *mut ::libc::c_char;
    pub fn rindex(arg1: *const ::libc::c_char, arg2: ::libc::c_int) ->
     *mut ::libc::c_char;
    pub fn ffs(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn strcasecmp(arg1: *const ::libc::c_char,
                      arg2: *const ::libc::c_char) -> ::libc::c_int;
    pub fn strncasecmp(arg1: *const ::libc::c_char,
                       arg2: *const ::libc::c_char, arg3: size_t) ->
     ::libc::c_int;
    pub fn ffsl(arg1: ::libc::c_long) -> ::libc::c_int;
    pub fn ffsll(arg1: ::libc::c_longlong) -> ::libc::c_int;
    pub fn fls(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn flsl(arg1: ::libc::c_long) -> ::libc::c_int;
    pub fn flsll(arg1: ::libc::c_longlong) -> ::libc::c_int;
    pub fn imaxabs(j: intmax_t) -> intmax_t;
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
    pub fn strtoimax(__nptr: *const ::libc::c_char,
                     __endptr: *mut *mut ::libc::c_char,
                     __base: ::libc::c_int) -> intmax_t;
    pub fn strtoumax(__nptr: *const ::libc::c_char,
                     __endptr: *mut *mut ::libc::c_char,
                     __base: ::libc::c_int) -> uintmax_t;
    pub fn wcstoimax(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t,
                     __base: ::libc::c_int) -> intmax_t;
    pub fn wcstoumax(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t,
                     __base: ::libc::c_int) -> uintmax_t;
    pub fn getattrlistbulk(arg1: ::libc::c_int, arg2: *mut ::libc::c_void,
                           arg3: *mut ::libc::c_void, arg4: size_t,
                           arg5: uint64_t) -> ::libc::c_int;
    pub fn faccessat(arg1: ::libc::c_int, arg2: *const ::libc::c_char,
                     arg3: ::libc::c_int, arg4: ::libc::c_int) ->
     ::libc::c_int;
    pub fn fchownat(arg1: ::libc::c_int, arg2: *const ::libc::c_char,
                    arg3: uid_t, arg4: gid_t, arg5: ::libc::c_int) ->
     ::libc::c_int;
    pub fn linkat(arg1: ::libc::c_int, arg2: *const ::libc::c_char,
                  arg3: ::libc::c_int, arg4: *const ::libc::c_char,
                  arg5: ::libc::c_int) -> ::libc::c_int;
    pub fn readlinkat(arg1: ::libc::c_int, arg2: *const ::libc::c_char,
                      arg3: *mut ::libc::c_char, arg4: size_t) -> ssize_t;
    pub fn symlinkat(arg1: *const ::libc::c_char, arg2: ::libc::c_int,
                     arg3: *const ::libc::c_char) -> ::libc::c_int;
    pub fn unlinkat(arg1: ::libc::c_int, arg2: *const ::libc::c_char,
                    arg3: ::libc::c_int) -> ::libc::c_int;
    pub fn getattrlistat(arg1: ::libc::c_int, arg2: *const ::libc::c_char,
                         arg3: *mut ::libc::c_void, arg4: *mut ::libc::c_void,
                         arg5: size_t, arg6: ::libc::c_ulong) ->
     ::libc::c_int;
    pub fn _exit(arg1: ::libc::c_int);
    pub fn access(arg1: *const ::libc::c_char, arg2: ::libc::c_int) ->
     ::libc::c_int;
    pub fn alarm(arg1: ::libc::c_uint) -> ::libc::c_uint;
    pub fn chdir(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn chown(arg1: *const ::libc::c_char, arg2: uid_t, arg3: gid_t) ->
     ::libc::c_int;
    pub fn close(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn dup(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn dup2(arg1: ::libc::c_int, arg2: ::libc::c_int) -> ::libc::c_int;
    pub fn execl(arg1: *const ::libc::c_char,
                 arg2: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn execle(arg1: *const ::libc::c_char,
                  arg2: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn execlp(arg1: *const ::libc::c_char,
                  arg2: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn execv(arg1: *const ::libc::c_char,
                 arg2: *const *mut ::libc::c_char) -> ::libc::c_int;
    pub fn execve(arg1: *const ::libc::c_char,
                  arg2: *const *mut ::libc::c_char,
                  arg3: *const *mut ::libc::c_char) -> ::libc::c_int;
    pub fn execvp(arg1: *const ::libc::c_char,
                  arg2: *const *mut ::libc::c_char) -> ::libc::c_int;
    pub fn fork() -> pid_t;
    pub fn fpathconf(arg1: ::libc::c_int, arg2: ::libc::c_int) ->
     ::libc::c_long;
    pub fn getcwd(arg1: *mut ::libc::c_char, arg2: size_t) ->
     *mut ::libc::c_char;
    pub fn getegid() -> gid_t;
    pub fn geteuid() -> uid_t;
    pub fn getgid() -> gid_t;
    pub fn getgroups(arg1: ::libc::c_int, arg2: *mut gid_t) -> ::libc::c_int;
    pub fn getlogin() -> *mut ::libc::c_char;
    pub fn getpgrp() -> pid_t;
    pub fn getpid() -> pid_t;
    pub fn getppid() -> pid_t;
    pub fn getuid() -> uid_t;
    pub fn isatty(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn link(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) ->
     ::libc::c_int;
    pub fn lseek(arg1: ::libc::c_int, arg2: off_t, arg3: ::libc::c_int) ->
     off_t;
    pub fn pathconf(arg1: *const ::libc::c_char, arg2: ::libc::c_int) ->
     ::libc::c_long;
    pub fn pause() -> ::libc::c_int;
    pub fn pipe(arg1: [::libc::c_int, ..2u]) -> ::libc::c_int;
    pub fn read(arg1: ::libc::c_int, arg2: *mut ::libc::c_void, arg3: size_t)
     -> ssize_t;
    pub fn rmdir(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn setgid(arg1: gid_t) -> ::libc::c_int;
    pub fn setpgid(arg1: pid_t, arg2: pid_t) -> ::libc::c_int;
    pub fn setsid() -> pid_t;
    pub fn setuid(arg1: uid_t) -> ::libc::c_int;
    pub fn sleep(arg1: ::libc::c_uint) -> ::libc::c_uint;
    pub fn sysconf(arg1: ::libc::c_int) -> ::libc::c_long;
    pub fn tcgetpgrp(arg1: ::libc::c_int) -> pid_t;
    pub fn tcsetpgrp(arg1: ::libc::c_int, arg2: pid_t) -> ::libc::c_int;
    pub fn ttyname(arg1: ::libc::c_int) -> *mut ::libc::c_char;
    pub fn ttyname_r(arg1: ::libc::c_int, arg2: *mut ::libc::c_char,
                     arg3: size_t) -> ::libc::c_int;
    pub fn unlink(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn write(arg1: ::libc::c_int, arg2: *const ::libc::c_void,
                 arg3: size_t) -> ssize_t;
    pub fn confstr(arg1: ::libc::c_int, arg2: *mut ::libc::c_char,
                   arg3: size_t) -> size_t;
    pub fn getopt(arg1: ::libc::c_int, arg2: *const *mut ::libc::c_char,
                  arg3: *const ::libc::c_char) -> ::libc::c_int;
    pub fn brk(arg1: *const ::libc::c_void) -> *mut ::libc::c_void;
    pub fn chroot(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn crypt(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) ->
     *mut ::libc::c_char;
    pub fn encrypt(arg1: *mut ::libc::c_char, arg2: ::libc::c_int);
    pub fn fchdir(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn gethostid() -> ::libc::c_long;
    pub fn getpgid(arg1: pid_t) -> pid_t;
    pub fn getsid(arg1: pid_t) -> pid_t;
    pub fn getdtablesize() -> ::libc::c_int;
    pub fn getpagesize() -> ::libc::c_int;
    pub fn getpass(arg1: *const ::libc::c_char) -> *mut ::libc::c_char;
    pub fn getwd(arg1: *mut ::libc::c_char) -> *mut ::libc::c_char;
    pub fn lchown(arg1: *const ::libc::c_char, arg2: uid_t, arg3: gid_t) ->
     ::libc::c_int;
    pub fn lockf(arg1: ::libc::c_int, arg2: ::libc::c_int, arg3: off_t) ->
     ::libc::c_int;
    pub fn nice(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn pread(arg1: ::libc::c_int, arg2: *mut ::libc::c_void, arg3: size_t,
                 arg4: off_t) -> ssize_t;
    pub fn pwrite(arg1: ::libc::c_int, arg2: *const ::libc::c_void,
                  arg3: size_t, arg4: off_t) -> ssize_t;
    pub fn sbrk(arg1: ::libc::c_int) -> *mut ::libc::c_void;
    pub fn setpgrp() -> pid_t;
    pub fn setregid(arg1: gid_t, arg2: gid_t) -> ::libc::c_int;
    pub fn setreuid(arg1: uid_t, arg2: uid_t) -> ::libc::c_int;
    pub fn sync();
    pub fn truncate(arg1: *const ::libc::c_char, arg2: off_t) ->
     ::libc::c_int;
    pub fn ualarm(arg1: useconds_t, arg2: useconds_t) -> useconds_t;
    pub fn usleep(arg1: useconds_t) -> ::libc::c_int;
    pub fn vfork() -> pid_t;
    pub fn fsync(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn ftruncate(arg1: ::libc::c_int, arg2: off_t) -> ::libc::c_int;
    pub fn getlogin_r(arg1: *mut ::libc::c_char, arg2: size_t) ->
     ::libc::c_int;
    pub fn fchown(arg1: ::libc::c_int, arg2: uid_t, arg3: gid_t) ->
     ::libc::c_int;
    pub fn gethostname(arg1: *mut ::libc::c_char, arg2: size_t) ->
     ::libc::c_int;
    pub fn readlink(arg1: *const ::libc::c_char, arg2: *mut ::libc::c_char,
                    arg3: size_t) -> ssize_t;
    pub fn setegid(arg1: gid_t) -> ::libc::c_int;
    pub fn seteuid(arg1: uid_t) -> ::libc::c_int;
    pub fn symlink(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn pselect(arg1: ::libc::c_int, arg2: *mut fd_set, arg3: *mut fd_set,
                   arg4: *mut fd_set, arg5: *const Struct_timespec,
                   arg6: *const sigset_t) -> ::libc::c_int;
    pub fn select(arg1: ::libc::c_int, arg2: *mut fd_set, arg3: *mut fd_set,
                  arg4: *mut fd_set, arg5: *mut Struct_timeval) ->
     ::libc::c_int;
    pub fn accessx_np(arg1: *const Struct_accessx_descriptor, arg2: size_t,
                      arg3: *mut ::libc::c_int, arg4: uid_t) -> ::libc::c_int;
    pub fn acct(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn add_profil(arg1: *mut ::libc::c_char, arg2: size_t,
                      arg3: ::libc::c_ulong, arg4: ::libc::c_uint) ->
     ::libc::c_int;
    pub fn endusershell();
    pub fn execvP(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char,
                  arg3: *const *mut ::libc::c_char) -> ::libc::c_int;
    pub fn fflagstostr(arg1: ::libc::c_ulong) -> *mut ::libc::c_char;
    pub fn getdomainname(arg1: *mut ::libc::c_char, arg2: ::libc::c_int) ->
     ::libc::c_int;
    pub fn getgrouplist(arg1: *const ::libc::c_char, arg2: ::libc::c_int,
                        arg3: *mut ::libc::c_int, arg4: *mut ::libc::c_int) ->
     ::libc::c_int;
    pub fn gethostuuid(arg1: uuid_t, arg2: *const Struct_timespec) ->
     ::libc::c_int;
    pub fn getmode(arg1: *const ::libc::c_void, arg2: mode_t) -> mode_t;
    pub fn getpeereid(arg1: ::libc::c_int, arg2: *mut uid_t, arg3: *mut gid_t)
     -> ::libc::c_int;
    pub fn getsgroups_np(arg1: *mut ::libc::c_int, arg2: uuid_t) ->
     ::libc::c_int;
    pub fn getusershell() -> *mut ::libc::c_char;
    pub fn getwgroups_np(arg1: *mut ::libc::c_int, arg2: uuid_t) ->
     ::libc::c_int;
    pub fn initgroups(arg1: *const ::libc::c_char, arg2: ::libc::c_int) ->
     ::libc::c_int;
    pub fn iruserok(arg1: ::libc::c_ulong, arg2: ::libc::c_int,
                    arg3: *const ::libc::c_char, arg4: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn iruserok_sa(arg1: *const ::libc::c_void, arg2: ::libc::c_int,
                       arg3: ::libc::c_int, arg4: *const ::libc::c_char,
                       arg5: *const ::libc::c_char) -> ::libc::c_int;
    pub fn issetugid() -> ::libc::c_int;
    pub fn mkdtemp(arg1: *mut ::libc::c_char) -> *mut ::libc::c_char;
    pub fn mkpath_np(path: *const ::libc::c_char, omode: mode_t) ->
     ::libc::c_int;
    pub fn mkstemps(arg1: *mut ::libc::c_char, arg2: ::libc::c_int) ->
     ::libc::c_int;
    pub fn nfssvc(arg1: ::libc::c_int, arg2: *mut ::libc::c_void) ->
     ::libc::c_int;
    pub fn profil(arg1: *mut ::libc::c_char, arg2: size_t,
                  arg3: ::libc::c_ulong, arg4: ::libc::c_uint) ->
     ::libc::c_int;
    pub fn pthread_setugid_np(arg1: uid_t, arg2: gid_t) -> ::libc::c_int;
    pub fn pthread_getugid_np(arg1: *mut uid_t, arg2: *mut gid_t) ->
     ::libc::c_int;
    pub fn rcmd(arg1: *mut *mut ::libc::c_char, arg2: ::libc::c_int,
                arg3: *const ::libc::c_char, arg4: *const ::libc::c_char,
                arg5: *const ::libc::c_char, arg6: *mut ::libc::c_int) ->
     ::libc::c_int;
    pub fn rcmd_af(arg1: *mut *mut ::libc::c_char, arg2: ::libc::c_int,
                   arg3: *const ::libc::c_char, arg4: *const ::libc::c_char,
                   arg5: *const ::libc::c_char, arg6: *mut ::libc::c_int,
                   arg7: ::libc::c_int) -> ::libc::c_int;
    pub fn reboot(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn revoke(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn rresvport(arg1: *mut ::libc::c_int) -> ::libc::c_int;
    pub fn rresvport_af(arg1: *mut ::libc::c_int, arg2: ::libc::c_int) ->
     ::libc::c_int;
    pub fn ruserok(arg1: *const ::libc::c_char, arg2: ::libc::c_int,
                   arg3: *const ::libc::c_char, arg4: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn setdomainname(arg1: *const ::libc::c_char, arg2: ::libc::c_int) ->
     ::libc::c_int;
    pub fn setgroups(arg1: ::libc::c_int, arg2: *const gid_t) ->
     ::libc::c_int;
    pub fn sethostid(arg1: ::libc::c_long);
    pub fn sethostname(arg1: *const ::libc::c_char, arg2: ::libc::c_int) ->
     ::libc::c_int;
    pub fn setlogin(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn setmode(arg1: *const ::libc::c_char) -> *mut ::libc::c_void;
    pub fn setrgid(arg1: gid_t) -> ::libc::c_int;
    pub fn setruid(arg1: uid_t) -> ::libc::c_int;
    pub fn setsgroups_np(arg1: ::libc::c_int, arg2: uuid_t) -> ::libc::c_int;
    pub fn setusershell();
    pub fn setwgroups_np(arg1: ::libc::c_int, arg2: uuid_t) -> ::libc::c_int;
    pub fn strtofflags(arg1: *mut *mut ::libc::c_char,
                       arg2: *mut ::libc::c_ulong, arg3: *mut ::libc::c_ulong)
     -> ::libc::c_int;
    pub fn swapon(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn syscall(arg1: ::libc::c_int, ...) -> ::libc::c_int;
    pub fn ttyslot() -> ::libc::c_int;
    pub fn undelete(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn unwhiteout(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn fgetattrlist(arg1: ::libc::c_int, arg2: *mut ::libc::c_void,
                        arg3: *mut ::libc::c_void, arg4: size_t,
                        arg5: ::libc::c_uint) -> ::libc::c_int;
    pub fn fsetattrlist(arg1: ::libc::c_int, arg2: *mut ::libc::c_void,
                        arg3: *mut ::libc::c_void, arg4: size_t,
                        arg5: ::libc::c_uint) -> ::libc::c_int;
    pub fn getattrlist(arg1: *const ::libc::c_char, arg2: *mut ::libc::c_void,
                       arg3: *mut ::libc::c_void, arg4: size_t,
                       arg5: ::libc::c_uint) -> ::libc::c_int;
    pub fn setattrlist(arg1: *const ::libc::c_char, arg2: *mut ::libc::c_void,
                       arg3: *mut ::libc::c_void, arg4: size_t,
                       arg5: ::libc::c_uint) -> ::libc::c_int;
    pub fn exchangedata(arg1: *const ::libc::c_char,
                        arg2: *const ::libc::c_char, arg3: ::libc::c_uint) ->
     ::libc::c_int;
    pub fn getdirentriesattr(arg1: ::libc::c_int, arg2: *mut ::libc::c_void,
                             arg3: *mut ::libc::c_void, arg4: size_t,
                             arg5: *mut ::libc::c_uint,
                             arg6: *mut ::libc::c_uint,
                             arg7: *mut ::libc::c_uint, arg8: ::libc::c_uint)
     -> ::libc::c_int;
    pub fn searchfs(arg1: *const ::libc::c_char,
                    arg2: *mut Struct_fssearchblock,
                    arg3: *mut ::libc::c_ulong, arg4: ::libc::c_uint,
                    arg5: ::libc::c_uint, arg6: *mut Struct_searchstate) ->
     ::libc::c_int;
    pub fn fsctl(arg1: *const ::libc::c_char, arg2: ::libc::c_ulong,
                 arg3: *mut ::libc::c_void, arg4: ::libc::c_uint) ->
     ::libc::c_int;
    pub fn ffsctl(arg1: ::libc::c_int, arg2: ::libc::c_ulong,
                  arg3: *mut ::libc::c_void, arg4: ::libc::c_uint) ->
     ::libc::c_int;
    pub fn fsync_volume_np(arg1: ::libc::c_int, arg2: ::libc::c_int) ->
     ::libc::c_int;
    pub fn sync_volume_np(arg1: *const ::libc::c_char, arg2: ::libc::c_int) ->
     ::libc::c_int;
    pub fn __math_errhandling() -> ::libc::c_int;
    pub fn __fpclassifyf(arg1: ::libc::c_float) -> ::libc::c_int;
    pub fn __fpclassifyd(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn __fpclassifyl(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_isfinitef(arg1: ::libc::c_float) -> ::libc::c_int;
    pub fn __inline_isfinited(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_isfinitel(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_isinff(arg1: ::libc::c_float) -> ::libc::c_int;
    pub fn __inline_isinfd(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_isinfl(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_isnanf(arg1: ::libc::c_float) -> ::libc::c_int;
    pub fn __inline_isnand(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_isnanl(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_isnormalf(arg1: ::libc::c_float) -> ::libc::c_int;
    pub fn __inline_isnormald(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_isnormall(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_signbitf(arg1: ::libc::c_float) -> ::libc::c_int;
    pub fn __inline_signbitd(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_signbitl(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn acosf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn acos(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn acosl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn asinf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn asin(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn asinl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn atanf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn atan(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn atanl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn atan2f(arg1: ::libc::c_float, arg2: ::libc::c_float) ->
     ::libc::c_float;
    pub fn atan2(arg1: ::libc::c_double, arg2: ::libc::c_double) ->
     ::libc::c_double;
    pub fn atan2l(arg1: ::libc::c_double, arg2: ::libc::c_double) ->
     ::libc::c_double;
    pub fn cosf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn cos(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn cosl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn sinf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn sin(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn sinl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn tanf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn tan(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn tanl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn acoshf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn acosh(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn acoshl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn asinhf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn asinh(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn asinhl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn atanhf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn atanh(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn atanhl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn coshf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn cosh(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn coshl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn sinhf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn sinh(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn sinhl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn tanhf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn tanh(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn tanhl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn expf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn exp(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn expl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn exp2f(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn exp2(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn exp2l(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn expm1f(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn expm1(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn expm1l(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn logf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn log(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn logl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn log10f(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn log10(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn log10l(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn log2f(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn log2(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn log2l(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn log1pf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn log1p(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn log1pl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn logbf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn logb(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn logbl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn modff(arg1: ::libc::c_float, arg2: *mut ::libc::c_float) ->
     ::libc::c_float;
    pub fn modf(arg1: ::libc::c_double, arg2: *mut ::libc::c_double) ->
     ::libc::c_double;
    pub fn modfl(arg1: ::libc::c_double, arg2: *mut ::libc::c_double) ->
     ::libc::c_double;
    pub fn ldexpf(arg1: ::libc::c_float, arg2: ::libc::c_int) ->
     ::libc::c_float;
    pub fn ldexp(arg1: ::libc::c_double, arg2: ::libc::c_int) ->
     ::libc::c_double;
    pub fn ldexpl(arg1: ::libc::c_double, arg2: ::libc::c_int) ->
     ::libc::c_double;
    pub fn frexpf(arg1: ::libc::c_float, arg2: *mut ::libc::c_int) ->
     ::libc::c_float;
    pub fn frexp(arg1: ::libc::c_double, arg2: *mut ::libc::c_int) ->
     ::libc::c_double;
    pub fn frexpl(arg1: ::libc::c_double, arg2: *mut ::libc::c_int) ->
     ::libc::c_double;
    pub fn ilogbf(arg1: ::libc::c_float) -> ::libc::c_int;
    pub fn ilogb(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn ilogbl(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn scalbnf(arg1: ::libc::c_float, arg2: ::libc::c_int) ->
     ::libc::c_float;
    pub fn scalbn(arg1: ::libc::c_double, arg2: ::libc::c_int) ->
     ::libc::c_double;
    pub fn scalbnl(arg1: ::libc::c_double, arg2: ::libc::c_int) ->
     ::libc::c_double;
    pub fn scalblnf(arg1: ::libc::c_float, arg2: ::libc::c_long) ->
     ::libc::c_float;
    pub fn scalbln(arg1: ::libc::c_double, arg2: ::libc::c_long) ->
     ::libc::c_double;
    pub fn scalblnl(arg1: ::libc::c_double, arg2: ::libc::c_long) ->
     ::libc::c_double;
    pub fn fabsf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn fabs(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn fabsl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn cbrtf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn cbrt(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn cbrtl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn hypotf(arg1: ::libc::c_float, arg2: ::libc::c_float) ->
     ::libc::c_float;
    pub fn hypot(arg1: ::libc::c_double, arg2: ::libc::c_double) ->
     ::libc::c_double;
    pub fn hypotl(arg1: ::libc::c_double, arg2: ::libc::c_double) ->
     ::libc::c_double;
    pub fn powf(arg1: ::libc::c_float, arg2: ::libc::c_float) ->
     ::libc::c_float;
    pub fn pow(arg1: ::libc::c_double, arg2: ::libc::c_double) ->
     ::libc::c_double;
    pub fn powl(arg1: ::libc::c_double, arg2: ::libc::c_double) ->
     ::libc::c_double;
    pub fn sqrtf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn sqrt(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn sqrtl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn erff(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn erf(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn erfl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn erfcf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn erfc(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn erfcl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn lgammaf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn lgamma(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn lgammal(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn tgammaf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn tgamma(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn tgammal(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn ceilf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn ceil(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn ceill(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn floorf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn floor(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn floorl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn nearbyintf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn nearbyint(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn nearbyintl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn rintf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn rint(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn rintl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn lrintf(arg1: ::libc::c_float) -> ::libc::c_long;
    pub fn lrint(arg1: ::libc::c_double) -> ::libc::c_long;
    pub fn lrintl(arg1: ::libc::c_double) -> ::libc::c_long;
    pub fn roundf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn round(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn roundl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn lroundf(arg1: ::libc::c_float) -> ::libc::c_long;
    pub fn lround(arg1: ::libc::c_double) -> ::libc::c_long;
    pub fn lroundl(arg1: ::libc::c_double) -> ::libc::c_long;
    pub fn llrintf(arg1: ::libc::c_float) -> ::libc::c_longlong;
    pub fn llrint(arg1: ::libc::c_double) -> ::libc::c_longlong;
    pub fn llrintl(arg1: ::libc::c_double) -> ::libc::c_longlong;
    pub fn llroundf(arg1: ::libc::c_float) -> ::libc::c_longlong;
    pub fn llround(arg1: ::libc::c_double) -> ::libc::c_longlong;
    pub fn llroundl(arg1: ::libc::c_double) -> ::libc::c_longlong;
    pub fn truncf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn trunc(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn truncl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn fmodf(arg1: ::libc::c_float, arg2: ::libc::c_float) ->
     ::libc::c_float;
    pub fn fmod(arg1: ::libc::c_double, arg2: ::libc::c_double) ->
     ::libc::c_double;
    pub fn fmodl(arg1: ::libc::c_double, arg2: ::libc::c_double) ->
     ::libc::c_double;
    pub fn remainderf(arg1: ::libc::c_float, arg2: ::libc::c_float) ->
     ::libc::c_float;
    pub fn remainder(arg1: ::libc::c_double, arg2: ::libc::c_double) ->
     ::libc::c_double;
    pub fn remainderl(arg1: ::libc::c_double, arg2: ::libc::c_double) ->
     ::libc::c_double;
    pub fn remquof(arg1: ::libc::c_float, arg2: ::libc::c_float,
                   arg3: *mut ::libc::c_int) -> ::libc::c_float;
    pub fn remquo(arg1: ::libc::c_double, arg2: ::libc::c_double,
                  arg3: *mut ::libc::c_int) -> ::libc::c_double;
    pub fn remquol(arg1: ::libc::c_double, arg2: ::libc::c_double,
                   arg3: *mut ::libc::c_int) -> ::libc::c_double;
    pub fn copysignf(arg1: ::libc::c_float, arg2: ::libc::c_float) ->
     ::libc::c_float;
    pub fn copysign(arg1: ::libc::c_double, arg2: ::libc::c_double) ->
     ::libc::c_double;
    pub fn copysignl(arg1: ::libc::c_double, arg2: ::libc::c_double) ->
     ::libc::c_double;
    pub fn nanf(arg1: *const ::libc::c_char) -> ::libc::c_float;
    pub fn nan(arg1: *const ::libc::c_char) -> ::libc::c_double;
    pub fn nanl(arg1: *const ::libc::c_char) -> ::libc::c_double;
    pub fn nextafterf(arg1: ::libc::c_float, arg2: ::libc::c_float) ->
     ::libc::c_float;
    pub fn nextafter(arg1: ::libc::c_double, arg2: ::libc::c_double) ->
     ::libc::c_double;
    pub fn nextafterl(arg1: ::libc::c_double, arg2: ::libc::c_double) ->
     ::libc::c_double;
    pub fn nexttoward(arg1: ::libc::c_double, arg2: ::libc::c_double) ->
     ::libc::c_double;
    pub fn nexttowardf(arg1: ::libc::c_float, arg2: ::libc::c_double) ->
     ::libc::c_float;
    pub fn nexttowardl(arg1: ::libc::c_double, arg2: ::libc::c_double) ->
     ::libc::c_double;
    pub fn fdimf(arg1: ::libc::c_float, arg2: ::libc::c_float) ->
     ::libc::c_float;
    pub fn fdim(arg1: ::libc::c_double, arg2: ::libc::c_double) ->
     ::libc::c_double;
    pub fn fdiml(arg1: ::libc::c_double, arg2: ::libc::c_double) ->
     ::libc::c_double;
    pub fn fmaxf(arg1: ::libc::c_float, arg2: ::libc::c_float) ->
     ::libc::c_float;
    pub fn fmax(arg1: ::libc::c_double, arg2: ::libc::c_double) ->
     ::libc::c_double;
    pub fn fmaxl(arg1: ::libc::c_double, arg2: ::libc::c_double) ->
     ::libc::c_double;
    pub fn fminf(arg1: ::libc::c_float, arg2: ::libc::c_float) ->
     ::libc::c_float;
    pub fn fmin(arg1: ::libc::c_double, arg2: ::libc::c_double) ->
     ::libc::c_double;
    pub fn fminl(arg1: ::libc::c_double, arg2: ::libc::c_double) ->
     ::libc::c_double;
    pub fn fmaf(arg1: ::libc::c_float, arg2: ::libc::c_float,
                arg3: ::libc::c_float) -> ::libc::c_float;
    pub fn fma(arg1: ::libc::c_double, arg2: ::libc::c_double,
               arg3: ::libc::c_double) -> ::libc::c_double;
    pub fn fmal(arg1: ::libc::c_double, arg2: ::libc::c_double,
                arg3: ::libc::c_double) -> ::libc::c_double;
    pub fn __inff() -> ::libc::c_float;
    pub fn __inf() -> ::libc::c_double;
    pub fn __infl() -> ::libc::c_double;
    pub fn __nan() -> ::libc::c_float;
    pub fn lgammaf_r(arg1: ::libc::c_float, arg2: *mut ::libc::c_int) ->
     ::libc::c_float;
    pub fn lgamma_r(arg1: ::libc::c_double, arg2: *mut ::libc::c_int) ->
     ::libc::c_double;
    pub fn lgammal_r(arg1: ::libc::c_double, arg2: *mut ::libc::c_int) ->
     ::libc::c_double;
    pub fn __exp10f(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn __exp10(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __sincosf(__x: ::libc::c_float, __sinp: *mut ::libc::c_float,
                     __cosp: *mut ::libc::c_float);
    pub fn __sincos(__x: ::libc::c_double, __sinp: *mut ::libc::c_double,
                    __cosp: *mut ::libc::c_double);
    pub fn __cospif(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn __cospi(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __sinpif(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn __sinpi(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __tanpif(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn __tanpi(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __sincospif(__x: ::libc::c_float, __sinp: *mut ::libc::c_float,
                       __cosp: *mut ::libc::c_float);
    pub fn __sincospi(__x: ::libc::c_double, __sinp: *mut ::libc::c_double,
                      __cosp: *mut ::libc::c_double);
    pub fn __sincosf_stret(arg1: ::libc::c_float) -> Struct___float2;
    pub fn __sincos_stret(arg1: ::libc::c_double) -> Struct___double2;
    pub fn __sincospif_stret(arg1: ::libc::c_float) -> Struct___float2;
    pub fn __sincospi_stret(arg1: ::libc::c_double) -> Struct___double2;
    pub fn j0(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn j1(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn jn(arg1: ::libc::c_int, arg2: ::libc::c_double) ->
     ::libc::c_double;
    pub fn y0(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn y1(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn yn(arg1: ::libc::c_int, arg2: ::libc::c_double) ->
     ::libc::c_double;
    pub fn scalb(arg1: ::libc::c_double, arg2: ::libc::c_double) ->
     ::libc::c_double;
    pub fn rinttol(arg1: ::libc::c_double) -> ::libc::c_long;
    pub fn roundtol(arg1: ::libc::c_double) -> ::libc::c_long;
    pub fn drem(arg1: ::libc::c_double, arg2: ::libc::c_double) ->
     ::libc::c_double;
    pub fn finite(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn gamma(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn significand(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn matherr(arg1: *mut Struct_exception) -> ::libc::c_int;
    pub fn eaccess(arg1: *const ::libc::c_char, arg2: ::libc::c_int) ->
     ::libc::c_int;
    pub fn setproctitle(fmt: *const ::libc::c_char, ...);
    pub fn ruby_xmalloc(arg1: size_t) -> *mut ::libc::c_void;
    pub fn ruby_xmalloc2(arg1: size_t, arg2: size_t) -> *mut ::libc::c_void;
    pub fn ruby_xcalloc(arg1: size_t, arg2: size_t) -> *mut ::libc::c_void;
    pub fn ruby_xrealloc(arg1: *mut ::libc::c_void, arg2: size_t) ->
     *mut ::libc::c_void;
    pub fn ruby_xrealloc2(arg1: *mut ::libc::c_void, arg2: size_t,
                          arg3: size_t) -> *mut ::libc::c_void;
    pub fn ruby_xfree(arg1: *mut ::libc::c_void);
    pub fn rb_int2inum(arg1: ::libc::c_long) -> VALUE;
    pub fn rb_uint2inum(arg1: VALUE) -> VALUE;
    pub fn rb_ll2inum(arg1: ::libc::c_longlong) -> VALUE;
    pub fn rb_ull2inum(arg1: ::libc::c_ulonglong) -> VALUE;
    pub fn rb_out_of_int(num: ::libc::c_long);
    pub fn rb_check_type(arg1: VALUE, arg2: ::libc::c_int);
    pub fn rb_str_to_str(arg1: VALUE) -> VALUE;
    pub fn rb_string_value(arg1: *mut VALUE) -> VALUE;
    pub fn rb_string_value_ptr(arg1: *mut VALUE) -> *mut ::libc::c_char;
    pub fn rb_string_value_cstr(arg1: *mut VALUE) -> *mut ::libc::c_char;
    pub fn rb_check_safe_obj(arg1: VALUE);
    pub fn rb_check_safe_str(arg1: VALUE);
    pub fn rb_str_export(arg1: VALUE) -> VALUE;
    pub fn rb_str_export_locale(arg1: VALUE) -> VALUE;
    pub fn rb_get_path(arg1: VALUE) -> VALUE;
    pub fn rb_get_path_no_checksafe(arg1: VALUE) -> VALUE;
    pub fn rb_secure(arg1: ::libc::c_int);
    pub fn rb_safe_level() -> ::libc::c_int;
    pub fn rb_set_safe_level(arg1: ::libc::c_int);
    pub fn rb_set_safe_level_force(arg1: ::libc::c_int);
    pub fn rb_secure_update(arg1: VALUE);
    pub fn rb_insecure_operation();
    pub fn rb_errinfo() -> VALUE;
    pub fn rb_set_errinfo(arg1: VALUE);
    pub fn rb_num2long(arg1: VALUE) -> ::libc::c_long;
    pub fn rb_num2ulong(arg1: VALUE) -> VALUE;
    pub fn rb_num2int(arg1: VALUE) -> ::libc::c_long;
    pub fn rb_fix2int(arg1: VALUE) -> ::libc::c_long;
    pub fn rb_num2uint(arg1: VALUE) -> ::libc::c_ulong;
    pub fn rb_fix2uint(arg1: VALUE) -> ::libc::c_ulong;
    pub fn rb_num2short(arg1: VALUE) -> ::libc::c_short;
    pub fn rb_num2ushort(arg1: VALUE) -> ::libc::c_ushort;
    pub fn rb_fix2short(arg1: VALUE) -> ::libc::c_short;
    pub fn rb_fix2ushort(arg1: VALUE) -> ::libc::c_ushort;
    pub fn rb_num2ll(arg1: VALUE) -> ::libc::c_longlong;
    pub fn rb_num2ull(arg1: VALUE) -> ::libc::c_ulonglong;
    pub fn rb_num2dbl(arg1: VALUE) -> ::libc::c_double;
    pub fn rb_uint2big(arg1: VALUE) -> VALUE;
    pub fn rb_int2big(arg1: ::libc::c_long) -> VALUE;
    pub fn rb_newobj() -> VALUE;
    pub fn rb_newobj_of(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_obj_setup(obj: VALUE, klass: VALUE, _type: VALUE) -> VALUE;
    pub fn rb_obj_hide(obj: VALUE) -> VALUE;
    pub fn rb_obj_reveal(obj: VALUE, klass: VALUE) -> VALUE;
    pub fn rb_float_value(arg1: VALUE) -> ::libc::c_double;
    pub fn rb_float_new(arg1: ::libc::c_double) -> VALUE;
    pub fn rb_float_new_in_heap(arg1: ::libc::c_double) -> VALUE;
    pub fn rb_data_object_alloc(arg1: VALUE, arg2: *mut ::libc::c_void,
                                arg3: RUBY_DATA_FUNC, arg4: RUBY_DATA_FUNC) ->
     VALUE;
    pub fn rb_data_typed_object_alloc(klass: VALUE,
                                      datap: *mut ::libc::c_void,
                                      arg1: *const rb_data_type_t) -> VALUE;
    pub fn rb_typeddata_inherited_p(child: *const rb_data_type_t,
                                    parent: *const rb_data_type_t) ->
     ::libc::c_int;
    pub fn rb_typeddata_is_kind_of(arg1: VALUE, arg2: *const rb_data_type_t)
     -> ::libc::c_int;
    pub fn rb_check_typeddata(arg1: VALUE, arg2: *const rb_data_type_t) ->
     *mut ::libc::c_void;
    pub fn rb_gc_writebarrier(a: VALUE, b: VALUE);
    pub fn rb_gc_writebarrier_unprotect_promoted(obj: VALUE);
    pub fn rb_alloc_tmp_buffer(store: *mut VALUE, len: ::libc::c_long) ->
     *mut ::libc::c_void;
    pub fn rb_free_tmp_buffer(store: *mut VALUE);
    pub fn rb_obj_infect(arg1: VALUE, arg2: VALUE);
    pub fn rb_glob(arg1: *const ::libc::c_char,
                   arg2:
                       ::std::option::Option<extern "C" fn
                                                 (arg1: *const ::libc::c_char,
                                                  arg2: VALUE,
                                                  arg3: *mut ::libc::c_void)>,
                   arg3: VALUE);
    pub fn ruby_glob(arg1: *const ::libc::c_char, arg2: ::libc::c_int,
                     arg3:
                         *mut ::std::option::Option<extern "C" fn
                                                        (arg1:
                                                             *const ::libc::c_char,
                                                         arg2: VALUE,
                                                         arg3:
                                                             *mut ::libc::c_void)
                                                        -> ::libc::c_int>,
                     arg4: VALUE) -> ::libc::c_int;
    pub fn ruby_brace_glob(arg1: *const ::libc::c_char, arg2: ::libc::c_int,
                           arg3:
                               *mut ::std::option::Option<extern "C" fn
                                                              (arg1:
                                                                   *const ::libc::c_char,
                                                               arg2: VALUE,
                                                               arg3:
                                                                   *mut ::libc::c_void)
                                                              ->
                                                                  ::libc::c_int>,
                           arg4: VALUE) -> ::libc::c_int;
    pub fn rb_define_class(arg1: *const ::libc::c_char, arg2: VALUE) -> VALUE;
    pub fn rb_define_module(arg1: *const ::libc::c_char) -> VALUE;
    pub fn rb_define_class_under(arg1: VALUE, arg2: *const ::libc::c_char,
                                 arg3: VALUE) -> VALUE;
    pub fn rb_define_module_under(arg1: VALUE, arg2: *const ::libc::c_char) ->
     VALUE;
    pub fn rb_include_module(arg1: VALUE, arg2: VALUE);
    pub fn rb_extend_object(arg1: VALUE, arg2: VALUE);
    pub fn rb_prepend_module(arg1: VALUE, arg2: VALUE);
    pub fn rb_gvar_undef_getter(id: ID, data: *mut ::libc::c_void,
                                gvar: *mut Struct_rb_global_variable) ->
     VALUE;
    pub fn rb_gvar_undef_setter(val: VALUE, id: ID, data: *mut ::libc::c_void,
                                gvar: *mut Struct_rb_global_variable);
    pub fn rb_gvar_undef_marker(var: *mut VALUE);
    pub fn rb_gvar_val_getter(id: ID, data: *mut ::libc::c_void,
                              gvar: *mut Struct_rb_global_variable) -> VALUE;
    pub fn rb_gvar_val_setter(val: VALUE, id: ID, data: *mut ::libc::c_void,
                              gvar: *mut Struct_rb_global_variable);
    pub fn rb_gvar_val_marker(var: *mut VALUE);
    pub fn rb_gvar_var_getter(id: ID, data: *mut ::libc::c_void,
                              gvar: *mut Struct_rb_global_variable) -> VALUE;
    pub fn rb_gvar_var_setter(val: VALUE, id: ID, data: *mut ::libc::c_void,
                              gvar: *mut Struct_rb_global_variable);
    pub fn rb_gvar_var_marker(var: *mut VALUE);
    pub fn rb_gvar_readonly_setter(val: VALUE, id: ID,
                                   data: *mut ::libc::c_void,
                                   gvar: *mut Struct_rb_global_variable);
    pub fn rb_define_variable(arg1: *const ::libc::c_char, arg2: *mut VALUE);
    pub fn rb_define_virtual_variable(arg1: *const ::libc::c_char,
                                      arg2:
                                          ::std::option::Option<extern "C" fn
                                                                    ()
                                                                    -> VALUE>,
                                      arg3:
                                          ::std::option::Option<extern "C" fn
                                                                    ()>);
    pub fn rb_define_hooked_variable(arg1: *const ::libc::c_char,
                                     arg2: *mut VALUE,
                                     arg3:
                                         ::std::option::Option<extern "C" fn()
                                                                   -> VALUE>,
                                     arg4:
                                         ::std::option::Option<extern "C" fn
                                                                   ()>);
    pub fn rb_define_readonly_variable(arg1: *const ::libc::c_char,
                                       arg2: *mut VALUE);
    pub fn rb_define_const(arg1: VALUE, arg2: *const ::libc::c_char,
                           arg3: VALUE);
    pub fn rb_define_global_const(arg1: *const ::libc::c_char, arg2: VALUE);
    pub fn rb_define_method(arg1: VALUE, arg2: *const ::libc::c_char,
                            arg3:
                                ::std::option::Option<extern "C" fn()
                                                          -> VALUE>,
                            arg4: ::libc::c_int);
    pub fn rb_define_module_function(arg1: VALUE, arg2: *const ::libc::c_char,
                                     arg3:
                                         ::std::option::Option<extern "C" fn()
                                                                   -> VALUE>,
                                     arg4: ::libc::c_int);
    pub fn rb_define_global_function(arg1: *const ::libc::c_char,
                                     arg2:
                                         ::std::option::Option<extern "C" fn()
                                                                   -> VALUE>,
                                     arg3: ::libc::c_int);
    pub fn rb_undef_method(arg1: VALUE, arg2: *const ::libc::c_char);
    pub fn rb_define_alias(arg1: VALUE, arg2: *const ::libc::c_char,
                           arg3: *const ::libc::c_char);
    pub fn rb_define_attr(arg1: VALUE, arg2: *const ::libc::c_char,
                          arg3: ::libc::c_int, arg4: ::libc::c_int);
    pub fn rb_global_variable(arg1: *mut VALUE);
    pub fn rb_gc_register_mark_object(arg1: VALUE);
    pub fn rb_gc_register_address(arg1: *mut VALUE);
    pub fn rb_gc_unregister_address(arg1: *mut VALUE);
    pub fn rb_intern(arg1: *const ::libc::c_char) -> ID;
    pub fn rb_intern2(arg1: *const ::libc::c_char, arg2: ::libc::c_long) ->
     ID;
    pub fn rb_intern_str(str: VALUE) -> ID;
    pub fn rb_id2name(arg1: ID) -> *const ::libc::c_char;
    pub fn rb_check_id(arg1: *mut VALUE) -> ID;
    pub fn rb_to_id(arg1: VALUE) -> ID;
    pub fn rb_id2str(arg1: ID) -> VALUE;
    pub fn rb_class2name(arg1: VALUE) -> *const ::libc::c_char;
    pub fn rb_obj_classname(arg1: VALUE) -> *const ::libc::c_char;
    pub fn rb_p(arg1: VALUE);
    pub fn rb_eval_string(arg1: *const ::libc::c_char) -> VALUE;
    pub fn rb_eval_string_protect(arg1: *const ::libc::c_char,
                                  arg2: *mut ::libc::c_int) -> VALUE;
    pub fn rb_eval_string_wrap(arg1: *const ::libc::c_char,
                               arg2: *mut ::libc::c_int) -> VALUE;
    pub fn rb_funcall(arg1: VALUE, arg2: ID, arg3: ::libc::c_int, ...) ->
     VALUE;
    pub fn rb_funcallv(arg1: VALUE, arg2: ID, arg3: ::libc::c_int,
                       arg4: *const VALUE) -> VALUE;
    pub fn rb_funcallv_public(arg1: VALUE, arg2: ID, arg3: ::libc::c_int,
                              arg4: *const VALUE) -> VALUE;
    pub fn rb_funcall_passing_block(arg1: VALUE, arg2: ID,
                                    arg3: ::libc::c_int, arg4: *const VALUE)
     -> VALUE;
    pub fn rb_funcall_with_block(arg1: VALUE, arg2: ID, arg3: ::libc::c_int,
                                 arg4: *const VALUE, arg5: VALUE) -> VALUE;
    pub fn rb_scan_args(arg1: ::libc::c_int, arg2: *const VALUE,
                        arg3: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn rb_call_super(arg1: ::libc::c_int, arg2: *const VALUE) -> VALUE;
    pub fn rb_gv_set(arg1: *const ::libc::c_char, arg2: VALUE) -> VALUE;
    pub fn rb_gv_get(arg1: *const ::libc::c_char) -> VALUE;
    pub fn rb_iv_get(arg1: VALUE, arg2: *const ::libc::c_char) -> VALUE;
    pub fn rb_iv_set(arg1: VALUE, arg2: *const ::libc::c_char, arg3: VALUE) ->
     VALUE;
    pub fn rb_equal(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ruby_verbose_ptr() -> *mut VALUE;
    pub fn rb_ruby_debug_ptr() -> *mut VALUE;
    pub fn rb_raise(arg1: VALUE, arg2: *const ::libc::c_char, ...);
    pub fn rb_fatal(arg1: *const ::libc::c_char, ...);
    pub fn rb_bug(arg1: *const ::libc::c_char, ...);
    pub fn rb_bug_errno(arg1: *const ::libc::c_char, arg2: ::libc::c_int);
    pub fn rb_sys_fail(arg1: *const ::libc::c_char);
    pub fn rb_sys_fail_str(arg1: VALUE);
    pub fn rb_mod_sys_fail(arg1: VALUE, arg2: *const ::libc::c_char);
    pub fn rb_mod_sys_fail_str(arg1: VALUE, arg2: VALUE);
    pub fn rb_readwrite_sys_fail(arg1: ::libc::c_int,
                                 arg2: *const ::libc::c_char);
    pub fn rb_iter_break();
    pub fn rb_iter_break_value(arg1: VALUE);
    pub fn rb_exit(arg1: ::libc::c_int);
    pub fn rb_notimplement();
    pub fn rb_syserr_new(arg1: ::libc::c_int, arg2: *const ::libc::c_char) ->
     VALUE;
    pub fn rb_syserr_new_str(n: ::libc::c_int, arg: VALUE) -> VALUE;
    pub fn rb_syserr_fail(arg1: ::libc::c_int, arg2: *const ::libc::c_char);
    pub fn rb_syserr_fail_str(arg1: ::libc::c_int, arg2: VALUE);
    pub fn rb_mod_syserr_fail(arg1: VALUE, arg2: ::libc::c_int,
                              arg3: *const ::libc::c_char);
    pub fn rb_mod_syserr_fail_str(arg1: VALUE, arg2: ::libc::c_int,
                                  arg3: VALUE);
    pub fn rb_warning(arg1: *const ::libc::c_char, ...);
    pub fn rb_compile_warning(arg1: *const ::libc::c_char,
                              arg2: ::libc::c_int,
                              arg3: *const ::libc::c_char, ...);
    pub fn rb_sys_warning(arg1: *const ::libc::c_char, ...);
    pub fn rb_warn(arg1: *const ::libc::c_char, ...);
    pub fn rb_compile_warn(arg1: *const ::libc::c_char, arg2: ::libc::c_int,
                           arg3: *const ::libc::c_char, ...);
    pub fn rb_each(arg1: VALUE) -> VALUE;
    pub fn rb_yield(arg1: VALUE) -> VALUE;
    pub fn rb_yield_values(n: ::libc::c_int, ...) -> VALUE;
    pub fn rb_yield_values2(n: ::libc::c_int, argv: *const VALUE) -> VALUE;
    pub fn rb_yield_splat(arg1: VALUE) -> VALUE;
    pub fn rb_yield_block(arg1: VALUE, arg2: VALUE, arg3: ::libc::c_int,
                          arg4: *const VALUE, arg5: VALUE) -> VALUE;
    pub fn rb_block_given_p() -> ::libc::c_int;
    pub fn rb_need_block();
    pub fn rb_iterate(arg1:
                          ::std::option::Option<extern "C" fn(arg1: VALUE)
                                                    -> VALUE>, arg2: VALUE,
                      arg3: ::std::option::Option<extern "C" fn() -> VALUE>,
                      arg4: VALUE) -> VALUE;
    pub fn rb_block_call(arg1: VALUE, arg2: ID, arg3: ::libc::c_int,
                         arg4: *const VALUE, arg5: rb_block_call_func_t,
                         arg6: VALUE) -> VALUE;
    pub fn rb_rescue(arg1: ::std::option::Option<extern "C" fn() -> VALUE>,
                     arg2: VALUE,
                     arg3: ::std::option::Option<extern "C" fn() -> VALUE>,
                     arg4: VALUE) -> VALUE;
    pub fn rb_rescue2(arg1: ::std::option::Option<extern "C" fn() -> VALUE>,
                      arg2: VALUE,
                      arg3: ::std::option::Option<extern "C" fn() -> VALUE>,
                      arg4: VALUE, ...) -> VALUE;
    pub fn rb_ensure(arg1: ::std::option::Option<extern "C" fn() -> VALUE>,
                     arg2: VALUE,
                     arg3: ::std::option::Option<extern "C" fn() -> VALUE>,
                     arg4: VALUE) -> VALUE;
    pub fn rb_catch(arg1: *const ::libc::c_char,
                    arg2: ::std::option::Option<extern "C" fn() -> VALUE>,
                    arg3: VALUE) -> VALUE;
    pub fn rb_catch_obj(arg1: VALUE,
                        arg2: ::std::option::Option<extern "C" fn() -> VALUE>,
                        arg3: VALUE) -> VALUE;
    pub fn rb_throw(arg1: *const ::libc::c_char, arg2: VALUE);
    pub fn rb_throw_obj(arg1: VALUE, arg2: VALUE);
    pub fn rb_require(arg1: *const ::libc::c_char) -> VALUE;
    pub fn st_init_table(arg1: *const Struct_st_hash_type) -> *mut st_table;
    pub fn st_init_table_with_size(arg1: *const Struct_st_hash_type,
                                   arg2: st_index_t) -> *mut st_table;
    pub fn st_init_numtable() -> *mut st_table;
    pub fn st_init_numtable_with_size(arg1: st_index_t) -> *mut st_table;
    pub fn st_init_strtable() -> *mut st_table;
    pub fn st_init_strtable_with_size(arg1: st_index_t) -> *mut st_table;
    pub fn st_init_strcasetable() -> *mut st_table;
    pub fn st_init_strcasetable_with_size(arg1: st_index_t) -> *mut st_table;
    pub fn st_delete(arg1: *mut st_table, arg2: *mut st_data_t,
                     arg3: *mut st_data_t) -> ::libc::c_int;
    pub fn st_delete_safe(arg1: *mut st_table, arg2: *mut st_data_t,
                          arg3: *mut st_data_t, arg4: st_data_t) ->
     ::libc::c_int;
    pub fn st_shift(arg1: *mut st_table, arg2: *mut st_data_t,
                    arg3: *mut st_data_t) -> ::libc::c_int;
    pub fn st_insert(arg1: *mut st_table, arg2: st_data_t, arg3: st_data_t) ->
     ::libc::c_int;
    pub fn st_insert2(arg1: *mut st_table, arg2: st_data_t, arg3: st_data_t,
                      arg4:
                          ::std::option::Option<extern "C" fn(arg1: st_data_t)
                                                    -> st_data_t>) ->
     ::libc::c_int;
    pub fn st_lookup(arg1: *mut st_table, arg2: st_data_t,
                     arg3: *mut st_data_t) -> ::libc::c_int;
    pub fn st_get_key(arg1: *mut st_table, arg2: st_data_t,
                      arg3: *mut st_data_t) -> ::libc::c_int;
    pub fn st_update(table: *mut st_table, key: st_data_t,
                     func:
                         *mut ::std::option::Option<extern "C" fn
                                                        (arg1: *mut st_data_t,
                                                         arg2: *mut st_data_t,
                                                         arg3: st_data_t,
                                                         arg4: ::libc::c_int)
                                                        -> ::libc::c_int>,
                     arg: st_data_t) -> ::libc::c_int;
    pub fn st_foreach(arg1: *mut st_table,
                      arg2:
                          ::std::option::Option<extern "C" fn()
                                                    -> ::libc::c_int>,
                      arg3: st_data_t) -> ::libc::c_int;
    pub fn st_foreach_check(arg1: *mut st_table,
                            arg2:
                                ::std::option::Option<extern "C" fn()
                                                          -> ::libc::c_int>,
                            arg3: st_data_t, arg4: st_data_t) ->
     ::libc::c_int;
    pub fn st_reverse_foreach(arg1: *mut st_table,
                              arg2:
                                  ::std::option::Option<extern "C" fn()
                                                            -> ::libc::c_int>,
                              arg3: st_data_t) -> ::libc::c_int;
    pub fn st_keys(table: *mut st_table, keys: *mut st_data_t,
                   size: st_index_t) -> st_index_t;
    pub fn st_keys_check(table: *mut st_table, keys: *mut st_data_t,
                         size: st_index_t, never: st_data_t) -> st_index_t;
    pub fn st_values(table: *mut st_table, values: *mut st_data_t,
                     size: st_index_t) -> st_index_t;
    pub fn st_values_check(table: *mut st_table, values: *mut st_data_t,
                           size: st_index_t, never: st_data_t) -> st_index_t;
    pub fn st_add_direct(arg1: *mut st_table, arg2: st_data_t,
                         arg3: st_data_t);
    pub fn st_free_table(arg1: *mut st_table);
    pub fn st_cleanup_safe(arg1: *mut st_table, arg2: st_data_t);
    pub fn st_clear(arg1: *mut st_table);
    pub fn st_copy(arg1: *mut st_table) -> *mut st_table;
    pub fn st_numcmp(arg1: st_data_t, arg2: st_data_t) -> ::libc::c_int;
    pub fn st_numhash(arg1: st_data_t) -> st_index_t;
    pub fn st_locale_insensitive_strcasecmp(s1: *const ::libc::c_char,
                                            s2: *const ::libc::c_char) ->
     ::libc::c_int;
    pub fn st_locale_insensitive_strncasecmp(s1: *const ::libc::c_char,
                                             s2: *const ::libc::c_char,
                                             n: size_t) -> ::libc::c_int;
    pub fn st_memsize(arg1: *const st_table) -> size_t;
    pub fn st_hash(ptr: *const ::libc::c_void, len: size_t, h: st_index_t) ->
     st_index_t;
    pub fn st_hash_uint32(h: st_index_t, i: uint32_t) -> st_index_t;
    pub fn st_hash_uint(h: st_index_t, i: st_index_t) -> st_index_t;
    pub fn st_hash_end(h: st_index_t) -> st_index_t;
    pub fn st_hash_start(h: st_index_t) -> st_index_t;
    pub fn rb_mem_clear(arg1: *mut VALUE, arg2: ::libc::c_long);
    pub fn rb_assoc_new(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_check_array_type(arg1: VALUE) -> VALUE;
    pub fn rb_ary_new() -> VALUE;
    pub fn rb_ary_new_capa(capa: ::libc::c_long) -> VALUE;
    pub fn rb_ary_new_from_args(n: ::libc::c_long, ...) -> VALUE;
    pub fn rb_ary_new_from_values(n: ::libc::c_long, elts: *const VALUE) ->
     VALUE;
    pub fn rb_ary_tmp_new(arg1: ::libc::c_long) -> VALUE;
    pub fn rb_ary_free(arg1: VALUE);
    pub fn rb_ary_modify(arg1: VALUE);
    pub fn rb_ary_freeze(arg1: VALUE) -> VALUE;
    pub fn rb_ary_shared_with_p(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_aref(arg1: ::libc::c_int, arg2: *mut VALUE, arg3: VALUE) ->
     VALUE;
    pub fn rb_ary_subseq(arg1: VALUE, arg2: ::libc::c_long,
                         arg3: ::libc::c_long) -> VALUE;
    pub fn rb_ary_store(arg1: VALUE, arg2: ::libc::c_long, arg3: VALUE);
    pub fn rb_ary_dup(arg1: VALUE) -> VALUE;
    pub fn rb_ary_resurrect(ary: VALUE) -> VALUE;
    pub fn rb_ary_to_ary(arg1: VALUE) -> VALUE;
    pub fn rb_ary_to_s(arg1: VALUE) -> VALUE;
    pub fn rb_ary_cat(arg1: VALUE, arg2: *const VALUE, arg3: ::libc::c_long)
     -> VALUE;
    pub fn rb_ary_push(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_pop(arg1: VALUE) -> VALUE;
    pub fn rb_ary_shift(arg1: VALUE) -> VALUE;
    pub fn rb_ary_unshift(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_entry(arg1: VALUE, arg2: ::libc::c_long) -> VALUE;
    pub fn rb_ary_each(arg1: VALUE) -> VALUE;
    pub fn rb_ary_join(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_reverse(arg1: VALUE) -> VALUE;
    pub fn rb_ary_rotate(arg1: VALUE, arg2: ::libc::c_long) -> VALUE;
    pub fn rb_ary_sort(arg1: VALUE) -> VALUE;
    pub fn rb_ary_sort_bang(arg1: VALUE) -> VALUE;
    pub fn rb_ary_delete(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_delete_at(arg1: VALUE, arg2: ::libc::c_long) -> VALUE;
    pub fn rb_ary_clear(arg1: VALUE) -> VALUE;
    pub fn rb_ary_plus(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_concat(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_assoc(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_rassoc(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_includes(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_cmp(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_replace(copy: VALUE, orig: VALUE) -> VALUE;
    pub fn rb_get_values_at(arg1: VALUE, arg2: ::libc::c_long,
                            arg3: ::libc::c_int, arg4: *mut VALUE,
                            arg5:
                                ::std::option::Option<extern "C" fn
                                                          (arg1: VALUE,
                                                           arg2:
                                                               ::libc::c_long)
                                                          -> VALUE>) -> VALUE;
    pub fn rb_ary_resize(ary: VALUE, len: ::libc::c_long) -> VALUE;
    pub fn rb_big_new(arg1: ::libc::c_long, arg2: ::libc::c_int) -> VALUE;
    pub fn rb_bigzero_p(x: VALUE) -> ::libc::c_int;
    pub fn rb_big_clone(arg1: VALUE) -> VALUE;
    pub fn rb_big_2comp(arg1: VALUE);
    pub fn rb_big_norm(arg1: VALUE) -> VALUE;
    pub fn rb_big_resize(big: VALUE, len: ::libc::c_long);
    pub fn rb_cstr_to_inum(arg1: *const ::libc::c_char, arg2: ::libc::c_int,
                           arg3: ::libc::c_int) -> VALUE;
    pub fn rb_str_to_inum(arg1: VALUE, arg2: ::libc::c_int,
                          arg3: ::libc::c_int) -> VALUE;
    pub fn rb_cstr2inum(arg1: *const ::libc::c_char, arg2: ::libc::c_int) ->
     VALUE;
    pub fn rb_str2inum(arg1: VALUE, arg2: ::libc::c_int) -> VALUE;
    pub fn rb_big2str(arg1: VALUE, arg2: ::libc::c_int) -> VALUE;
    pub fn rb_big2str0(arg1: VALUE, arg2: ::libc::c_int, arg3: ::libc::c_int)
     -> VALUE;
    pub fn rb_big2long(arg1: VALUE) -> ::libc::c_long;
    pub fn rb_big2ulong(arg1: VALUE) -> VALUE;
    pub fn rb_big2ulong_pack(x: VALUE) -> VALUE;
    pub fn rb_big2ll(arg1: VALUE) -> ::libc::c_longlong;
    pub fn rb_big2ull(arg1: VALUE) -> ::libc::c_ulonglong;
    pub fn rb_quad_pack(arg1: *mut ::libc::c_char, arg2: VALUE);
    pub fn rb_quad_unpack(arg1: *const ::libc::c_char, arg2: ::libc::c_int) ->
     VALUE;
    pub fn rb_big_pack(val: VALUE, buf: *mut ::libc::c_ulong,
                       num_longs: ::libc::c_long);
    pub fn rb_big_unpack(buf: *mut ::libc::c_ulong, num_longs: ::libc::c_long)
     -> VALUE;
    pub fn rb_uv_to_utf8(arg1: [::libc::c_char, ..6u], arg2: ::libc::c_ulong)
     -> ::libc::c_int;
    pub fn rb_dbl2big(arg1: ::libc::c_double) -> VALUE;
    pub fn rb_big2dbl(arg1: VALUE) -> ::libc::c_double;
    pub fn rb_big_cmp(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_eq(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_eql(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_plus(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_minus(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_mul(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_div(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_idiv(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_modulo(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_divmod(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_pow(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_and(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_or(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_xor(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_lshift(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_rshift(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_integer_pack(val: VALUE, words: *mut ::libc::c_void,
                           numwords: size_t, wordsize: size_t, nails: size_t,
                           flags: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_integer_unpack(words: *const ::libc::c_void, numwords: size_t,
                             wordsize: size_t, nails: size_t,
                             flags: ::libc::c_int) -> VALUE;
    pub fn rb_absint_size(val: VALUE, nlz_bits_ret: *mut ::libc::c_int) ->
     size_t;
    pub fn rb_absint_numwords(val: VALUE, word_numbits: size_t,
                              nlz_bits_ret: *mut size_t) -> size_t;
    pub fn rb_absint_singlebit_p(val: VALUE) -> ::libc::c_int;
    pub fn rb_rational_raw(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_rational_new(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_Rational(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_flt_rationalize_with_prec(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_flt_rationalize(arg1: VALUE) -> VALUE;
    pub fn rb_complex_raw(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_complex_new(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_complex_polar(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_Complex(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_class_boot(arg1: VALUE) -> VALUE;
    pub fn rb_class_new(arg1: VALUE) -> VALUE;
    pub fn rb_mod_init_copy(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_singleton_class_clone(arg1: VALUE) -> VALUE;
    pub fn rb_singleton_class_attached(arg1: VALUE, arg2: VALUE);
    pub fn rb_make_metaclass(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_check_inheritable(arg1: VALUE);
    pub fn rb_class_inherited(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_define_class_id(arg1: ID, arg2: VALUE) -> VALUE;
    pub fn rb_define_class_id_under(arg1: VALUE, arg2: ID, arg3: VALUE) ->
     VALUE;
    pub fn rb_module_new() -> VALUE;
    pub fn rb_define_module_id(arg1: ID) -> VALUE;
    pub fn rb_define_module_id_under(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_include_class_new(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_mod_included_modules(arg1: VALUE) -> VALUE;
    pub fn rb_mod_include_p(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_mod_ancestors(arg1: VALUE) -> VALUE;
    pub fn rb_class_instance_methods(arg1: ::libc::c_int, arg2: *mut VALUE,
                                     arg3: VALUE) -> VALUE;
    pub fn rb_class_public_instance_methods(arg1: ::libc::c_int,
                                            arg2: *mut VALUE, arg3: VALUE) ->
     VALUE;
    pub fn rb_class_protected_instance_methods(arg1: ::libc::c_int,
                                               arg2: *mut VALUE, arg3: VALUE)
     -> VALUE;
    pub fn rb_class_private_instance_methods(arg1: ::libc::c_int,
                                             arg2: *mut VALUE, arg3: VALUE) ->
     VALUE;
    pub fn rb_obj_singleton_methods(arg1: ::libc::c_int, arg2: *mut VALUE,
                                    arg3: VALUE) -> VALUE;
    pub fn rb_define_method_id(arg1: VALUE, arg2: ID,
                               arg3:
                                   ::std::option::Option<extern "C" fn()
                                                             -> VALUE>,
                               arg4: ::libc::c_int);
    pub fn rb_frozen_class_p(arg1: VALUE);
    pub fn rb_undef(arg1: VALUE, arg2: ID);
    pub fn rb_define_protected_method(arg1: VALUE,
                                      arg2: *const ::libc::c_char,
                                      arg3:
                                          ::std::option::Option<extern "C" fn
                                                                    ()
                                                                    -> VALUE>,
                                      arg4: ::libc::c_int);
    pub fn rb_define_private_method(arg1: VALUE, arg2: *const ::libc::c_char,
                                    arg3:
                                        ::std::option::Option<extern "C" fn()
                                                                  -> VALUE>,
                                    arg4: ::libc::c_int);
    pub fn rb_define_singleton_method(arg1: VALUE,
                                      arg2: *const ::libc::c_char,
                                      arg3:
                                          ::std::option::Option<extern "C" fn
                                                                    ()
                                                                    -> VALUE>,
                                      arg4: ::libc::c_int);
    pub fn rb_singleton_class(arg1: VALUE) -> VALUE;
    pub fn rb_cmpint(arg1: VALUE, arg2: VALUE, arg3: VALUE) -> ::libc::c_int;
    pub fn rb_cmperr(arg1: VALUE, arg2: VALUE);
    pub fn rb_fiber_new(arg1: ::std::option::Option<extern "C" fn() -> VALUE>,
                        arg2: VALUE) -> VALUE;
    pub fn rb_fiber_resume(fib: VALUE, argc: ::libc::c_int, args: *mut VALUE)
     -> VALUE;
    pub fn rb_fiber_yield(argc: ::libc::c_int, args: *mut VALUE) -> VALUE;
    pub fn rb_fiber_current() -> VALUE;
    pub fn rb_fiber_alive_p(arg1: VALUE) -> VALUE;
    pub fn rb_enum_values_pack(arg1: ::libc::c_int, arg2: *const VALUE) ->
     VALUE;
    pub fn rb_enumeratorize(arg1: VALUE, arg2: VALUE, arg3: ::libc::c_int,
                            arg4: *mut VALUE) -> VALUE;
    pub fn rb_enumeratorize_with_size(arg1: VALUE, arg2: VALUE,
                                      arg3: ::libc::c_int, arg4: *mut VALUE,
                                      arg5:
                                          *mut ::std::option::Option<extern "C" fn
                                                                         (arg1:
                                                                              VALUE,
                                                                          arg2:
                                                                              VALUE,
                                                                          arg3:
                                                                              VALUE)
                                                                         ->
                                                                             VALUE>)
     -> VALUE;
    pub fn rb_exc_new(arg1: VALUE, arg2: *const ::libc::c_char,
                      arg3: ::libc::c_long) -> VALUE;
    pub fn rb_exc_new_cstr(arg1: VALUE, arg2: *const ::libc::c_char) -> VALUE;
    pub fn rb_exc_new_str(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_loaderror(arg1: *const ::libc::c_char, ...);
    pub fn rb_loaderror_with_path(path: VALUE,
                                  arg1: *const ::libc::c_char, ...);
    pub fn rb_name_error(arg1: ID, arg2: *const ::libc::c_char, ...);
    pub fn rb_name_error_str(arg1: VALUE, arg2: *const ::libc::c_char, ...);
    pub fn rb_invalid_str(arg1: *const ::libc::c_char,
                          arg2: *const ::libc::c_char);
    pub fn rb_compile_error(arg1: *const ::libc::c_char, arg2: ::libc::c_int,
                            arg3: *const ::libc::c_char, ...);
    pub fn rb_compile_error_with_enc(arg1: *const ::libc::c_char,
                                     arg2: ::libc::c_int,
                                     arg3: *mut ::libc::c_void,
                                     arg4: *const ::libc::c_char, ...);
    pub fn rb_compile_error_append(arg1: *const ::libc::c_char, ...);
    pub fn rb_error_frozen(arg1: *const ::libc::c_char);
    pub fn rb_error_untrusted(arg1: VALUE);
    pub fn rb_check_frozen(arg1: VALUE);
    pub fn rb_check_trusted(arg1: VALUE);
    pub fn rb_check_copyable(obj: VALUE, orig: VALUE);
    pub fn rb_sourceline() -> ::libc::c_int;
    pub fn rb_sourcefile() -> *const ::libc::c_char;
    pub fn rb_check_funcall(arg1: VALUE, arg2: ID, arg3: ::libc::c_int,
                            arg4: *const VALUE) -> VALUE;
    pub fn rb_error_arity(arg1: ::libc::c_int, arg2: ::libc::c_int,
                          arg3: ::libc::c_int);
    pub fn rb_fd_init(arg1: *mut rb_fdset_t);
    pub fn rb_fd_term(arg1: *mut rb_fdset_t);
    pub fn rb_fd_zero(arg1: *mut rb_fdset_t);
    pub fn rb_fd_set(arg1: ::libc::c_int, arg2: *mut rb_fdset_t);
    pub fn rb_fd_clr(arg1: ::libc::c_int, arg2: *mut rb_fdset_t);
    pub fn rb_fd_isset(arg1: ::libc::c_int, arg2: *const rb_fdset_t) ->
     ::libc::c_int;
    pub fn rb_fd_copy(arg1: *mut rb_fdset_t, arg2: *const fd_set,
                      arg3: ::libc::c_int);
    pub fn rb_fd_dup(dst: *mut rb_fdset_t, src: *const rb_fdset_t);
    pub fn rb_fd_select(arg1: ::libc::c_int, arg2: *mut rb_fdset_t,
                        arg3: *mut rb_fdset_t, arg4: *mut rb_fdset_t,
                        arg5: *mut Struct_timeval) -> ::libc::c_int;
    pub fn rb_exc_raise(arg1: VALUE);
    pub fn rb_exc_fatal(arg1: VALUE);
    pub fn rb_f_exit(arg1: ::libc::c_int, arg2: *mut VALUE) -> VALUE;
    pub fn rb_f_abort(arg1: ::libc::c_int, arg2: *mut VALUE) -> VALUE;
    pub fn rb_remove_method(arg1: VALUE, arg2: *const ::libc::c_char);
    pub fn rb_remove_method_id(arg1: VALUE, arg2: ID);
    pub fn rb_define_alloc_func(arg1: VALUE, arg2: rb_alloc_func_t);
    pub fn rb_undef_alloc_func(arg1: VALUE);
    pub fn rb_get_alloc_func(arg1: VALUE) -> rb_alloc_func_t;
    pub fn rb_clear_cache();
    pub fn rb_clear_constant_cache();
    pub fn rb_clear_method_cache_by_class(arg1: VALUE);
    pub fn rb_alias(arg1: VALUE, arg2: ID, arg3: ID);
    pub fn rb_attr(arg1: VALUE, arg2: ID, arg3: ::libc::c_int,
                   arg4: ::libc::c_int, arg5: ::libc::c_int);
    pub fn rb_method_boundp(arg1: VALUE, arg2: ID, arg3: ::libc::c_int) ->
     ::libc::c_int;
    pub fn rb_method_basic_definition_p(arg1: VALUE, arg2: ID) ->
     ::libc::c_int;
    pub fn rb_eval_cmd(arg1: VALUE, arg2: VALUE, arg3: ::libc::c_int) ->
     VALUE;
    pub fn rb_obj_respond_to(arg1: VALUE, arg2: ID, arg3: ::libc::c_int) ->
     ::libc::c_int;
    pub fn rb_respond_to(arg1: VALUE, arg2: ID) -> ::libc::c_int;
    pub fn rb_f_notimplement(argc: ::libc::c_int, argv: *mut VALUE,
                             obj: VALUE) -> VALUE;
    pub fn rb_interrupt();
    pub fn rb_apply(arg1: VALUE, arg2: ID, arg3: VALUE) -> VALUE;
    pub fn rb_backtrace();
    pub fn rb_frame_this_func() -> ID;
    pub fn rb_obj_instance_eval(arg1: ::libc::c_int, arg2: *mut VALUE,
                                arg3: VALUE) -> VALUE;
    pub fn rb_obj_instance_exec(arg1: ::libc::c_int, arg2: *mut VALUE,
                                arg3: VALUE) -> VALUE;
    pub fn rb_mod_module_eval(arg1: ::libc::c_int, arg2: *mut VALUE,
                              arg3: VALUE) -> VALUE;
    pub fn rb_mod_module_exec(arg1: ::libc::c_int, arg2: *mut VALUE,
                              arg3: VALUE) -> VALUE;
    pub fn rb_load(arg1: VALUE, arg2: ::libc::c_int);
    pub fn rb_load_protect(arg1: VALUE, arg2: ::libc::c_int,
                           arg3: *mut ::libc::c_int);
    pub fn rb_jump_tag(arg1: ::libc::c_int);
    pub fn rb_provided(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn rb_feature_provided(arg1: *const ::libc::c_char,
                               arg2: *mut *const ::libc::c_char) ->
     ::libc::c_int;
    pub fn rb_provide(arg1: *const ::libc::c_char);
    pub fn rb_f_require(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_require_safe(arg1: VALUE, arg2: ::libc::c_int) -> VALUE;
    pub fn rb_obj_call_init(arg1: VALUE, arg2: ::libc::c_int,
                            arg3: *mut VALUE);
    pub fn rb_class_new_instance(arg1: ::libc::c_int, arg2: *mut VALUE,
                                 arg3: VALUE) -> VALUE;
    pub fn rb_block_proc() -> VALUE;
    pub fn rb_block_lambda() -> VALUE;
    pub fn rb_proc_new(arg1: ::std::option::Option<extern "C" fn() -> VALUE>,
                       arg2: VALUE) -> VALUE;
    pub fn rb_obj_is_proc(arg1: VALUE) -> VALUE;
    pub fn rb_proc_call(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_proc_call_with_block(arg1: VALUE, argc: ::libc::c_int,
                                   argv: *const VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_proc_arity(arg1: VALUE) -> ::libc::c_int;
    pub fn rb_proc_lambda_p(arg1: VALUE) -> VALUE;
    pub fn rb_binding_new() -> VALUE;
    pub fn rb_obj_method(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_obj_is_method(arg1: VALUE) -> VALUE;
    pub fn rb_method_call(arg1: ::libc::c_int, arg2: *mut VALUE, arg3: VALUE)
     -> VALUE;
    pub fn rb_method_call_with_block(arg1: ::libc::c_int, arg2: *mut VALUE,
                                     arg3: VALUE, arg4: VALUE) -> VALUE;
    pub fn rb_mod_method_arity(arg1: VALUE, arg2: ID) -> ::libc::c_int;
    pub fn rb_obj_method_arity(arg1: VALUE, arg2: ID) -> ::libc::c_int;
    pub fn rb_protect(arg1:
                          ::std::option::Option<extern "C" fn(arg1: VALUE)
                                                    -> VALUE>, arg2: VALUE,
                      arg3: *mut ::libc::c_int) -> VALUE;
    pub fn rb_set_end_proc(arg1:
                               ::std::option::Option<extern "C" fn
                                                         (arg1: VALUE)>,
                           arg2: VALUE);
    pub fn rb_exec_end_proc();
    pub fn rb_thread_schedule();
    pub fn rb_thread_wait_fd(arg1: ::libc::c_int);
    pub fn rb_thread_fd_writable(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_thread_fd_close(arg1: ::libc::c_int);
    pub fn rb_thread_alone() -> ::libc::c_int;
    pub fn rb_thread_polling();
    pub fn rb_thread_sleep(arg1: ::libc::c_int);
    pub fn rb_thread_sleep_forever();
    pub fn rb_thread_sleep_deadly();
    pub fn rb_thread_stop() -> VALUE;
    pub fn rb_thread_wakeup(arg1: VALUE) -> VALUE;
    pub fn rb_thread_wakeup_alive(arg1: VALUE) -> VALUE;
    pub fn rb_thread_run(arg1: VALUE) -> VALUE;
    pub fn rb_thread_kill(arg1: VALUE) -> VALUE;
    pub fn rb_thread_create(arg1:
                                ::std::option::Option<extern "C" fn()
                                                          -> VALUE>,
                            arg2: *mut ::libc::c_void) -> VALUE;
    pub fn rb_thread_select(arg1: ::libc::c_int, arg2: *mut fd_set,
                            arg3: *mut fd_set, arg4: *mut fd_set,
                            arg5: *mut Struct_timeval) -> ::libc::c_int;
    pub fn rb_thread_fd_select(arg1: ::libc::c_int, arg2: *mut rb_fdset_t,
                               arg3: *mut rb_fdset_t, arg4: *mut rb_fdset_t,
                               arg5: *mut Struct_timeval) -> ::libc::c_int;
    pub fn rb_thread_wait_for(arg1: Struct_timeval);
    pub fn rb_thread_current() -> VALUE;
    pub fn rb_thread_main() -> VALUE;
    pub fn rb_thread_local_aref(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_thread_local_aset(arg1: VALUE, arg2: ID, arg3: VALUE) -> VALUE;
    pub fn rb_thread_atfork();
    pub fn rb_thread_atfork_before_exec();
    pub fn rb_exec_recursive(arg1:
                                 ::std::option::Option<extern "C" fn
                                                           (arg1: VALUE,
                                                            arg2: VALUE,
                                                            arg3:
                                                                ::libc::c_int)
                                                           -> VALUE>,
                             arg2: VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_exec_recursive_paired(arg1:
                                        ::std::option::Option<extern "C" fn
                                                                  (arg1:
                                                                       VALUE,
                                                                   arg2:
                                                                       VALUE,
                                                                   arg3:
                                                                       ::libc::c_int)
                                                                  -> VALUE>,
                                    arg2: VALUE, arg3: VALUE, arg4: VALUE) ->
     VALUE;
    pub fn rb_exec_recursive_outer(arg1:
                                       ::std::option::Option<extern "C" fn
                                                                 (arg1: VALUE,
                                                                  arg2: VALUE,
                                                                  arg3:
                                                                      ::libc::c_int)
                                                                 -> VALUE>,
                                   arg2: VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_exec_recursive_paired_outer(arg1:
                                              ::std::option::Option<extern "C" fn
                                                                        (arg1:
                                                                             VALUE,
                                                                         arg2:
                                                                             VALUE,
                                                                         arg3:
                                                                             ::libc::c_int)
                                                                        ->
                                                                            VALUE>,
                                          arg2: VALUE, arg3: VALUE,
                                          arg4: VALUE) -> VALUE;
    pub fn rb_dir_getwd() -> VALUE;
    pub fn rb_file_s_expand_path(arg1: ::libc::c_int, arg2: *mut VALUE) ->
     VALUE;
    pub fn rb_file_expand_path(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_file_s_absolute_path(arg1: ::libc::c_int, arg2: *mut VALUE) ->
     VALUE;
    pub fn rb_file_absolute_path(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_file_dirname(fname: VALUE) -> VALUE;
    pub fn rb_find_file_ext_safe(arg1: *mut VALUE,
                                 arg2: *const *const ::libc::c_char,
                                 arg3: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_find_file_safe(arg1: VALUE, arg2: ::libc::c_int) -> VALUE;
    pub fn rb_find_file_ext(arg1: *mut VALUE,
                            arg2: *const *const ::libc::c_char) ->
     ::libc::c_int;
    pub fn rb_find_file(arg1: VALUE) -> VALUE;
    pub fn rb_file_directory_p(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_str_encode_ospath(arg1: VALUE) -> VALUE;
    pub fn rb_is_absolute_path(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn rb_memerror();
    pub fn rb_during_gc() -> ::libc::c_int;
    pub fn rb_gc_mark_locations(arg1: *mut VALUE, arg2: *mut VALUE);
    pub fn rb_mark_tbl(arg1: *mut Struct_st_table);
    pub fn rb_mark_set(arg1: *mut Struct_st_table);
    pub fn rb_mark_hash(arg1: *mut Struct_st_table);
    pub fn rb_gc_mark_maybe(arg1: VALUE);
    pub fn rb_gc_mark(arg1: VALUE);
    pub fn rb_gc_force_recycle(arg1: VALUE);
    pub fn rb_gc();
    pub fn rb_gc_copy_finalizer(arg1: VALUE, arg2: VALUE);
    pub fn rb_gc_finalize_deferred();
    pub fn rb_gc_call_finalizer_at_exit();
    pub fn rb_gc_enable() -> VALUE;
    pub fn rb_gc_disable() -> VALUE;
    pub fn rb_gc_start() -> VALUE;
    pub fn rb_gc_set_params();
    pub fn rb_define_finalizer(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_undefine_finalizer(arg1: VALUE) -> VALUE;
    pub fn rb_gc_count() -> size_t;
    pub fn rb_gc_stat(arg1: VALUE) -> size_t;
    pub fn rb_gc_latest_gc_info(arg1: VALUE) -> VALUE;
    pub fn st_foreach_safe(arg1: *mut Struct_st_table,
                           arg2:
                               ::std::option::Option<extern "C" fn()
                                                         -> ::libc::c_int>,
                           arg3: st_data_t);
    pub fn rb_check_hash_type(arg1: VALUE) -> VALUE;
    pub fn rb_hash_foreach(arg1: VALUE,
                           arg2:
                               ::std::option::Option<extern "C" fn()
                                                         -> ::libc::c_int>,
                           arg3: VALUE);
    pub fn rb_hash(arg1: VALUE) -> VALUE;
    pub fn rb_hash_new() -> VALUE;
    pub fn rb_hash_dup(arg1: VALUE) -> VALUE;
    pub fn rb_hash_freeze(arg1: VALUE) -> VALUE;
    pub fn rb_hash_aref(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_hash_lookup(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_hash_lookup2(arg1: VALUE, arg2: VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_hash_fetch(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_hash_aset(arg1: VALUE, arg2: VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_hash_clear(arg1: VALUE) -> VALUE;
    pub fn rb_hash_delete_if(arg1: VALUE) -> VALUE;
    pub fn rb_hash_delete(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_hash_set_ifnone(hash: VALUE, ifnone: VALUE) -> VALUE;
    pub fn rb_hash_update_by(hash1: VALUE, hash2: VALUE,
                             func:
                                 *mut ::std::option::Option<extern "C" fn
                                                                (arg1: VALUE,
                                                                 arg2: VALUE,
                                                                 arg3: VALUE)
                                                                -> VALUE>) ->
     VALUE;
    pub fn rb_hash_tbl(arg1: VALUE) -> *mut Struct_st_table;
    pub fn rb_path_check(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn rb_env_path_tainted() -> ::libc::c_int;
    pub fn rb_env_clear() -> VALUE;
    pub fn rb_io_write(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_io_gets(arg1: VALUE) -> VALUE;
    pub fn rb_io_getbyte(arg1: VALUE) -> VALUE;
    pub fn rb_io_ungetc(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_io_ungetbyte(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_io_close(arg1: VALUE) -> VALUE;
    pub fn rb_io_flush(arg1: VALUE) -> VALUE;
    pub fn rb_io_eof(arg1: VALUE) -> VALUE;
    pub fn rb_io_binmode(arg1: VALUE) -> VALUE;
    pub fn rb_io_ascii8bit_binmode(arg1: VALUE) -> VALUE;
    pub fn rb_io_addstr(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_io_printf(arg1: ::libc::c_int, arg2: *mut VALUE, arg3: VALUE) ->
     VALUE;
    pub fn rb_io_print(arg1: ::libc::c_int, arg2: *mut VALUE, arg3: VALUE) ->
     VALUE;
    pub fn rb_io_puts(arg1: ::libc::c_int, arg2: *mut VALUE, arg3: VALUE) ->
     VALUE;
    pub fn rb_io_fdopen(arg1: ::libc::c_int, arg2: ::libc::c_int,
                        arg3: *const ::libc::c_char) -> VALUE;
    pub fn rb_io_get_io(arg1: VALUE) -> VALUE;
    pub fn rb_file_open(arg1: *const ::libc::c_char,
                        arg2: *const ::libc::c_char) -> VALUE;
    pub fn rb_file_open_str(arg1: VALUE, arg2: *const ::libc::c_char) ->
     VALUE;
    pub fn rb_gets() -> VALUE;
    pub fn rb_write_error(arg1: *const ::libc::c_char);
    pub fn rb_write_error2(arg1: *const ::libc::c_char, arg2: ::libc::c_long);
    pub fn rb_close_before_exec(lowfd: ::libc::c_int, maxhint: ::libc::c_int,
                                noclose_fds: VALUE);
    pub fn rb_pipe(pipes: *mut ::libc::c_int) -> ::libc::c_int;
    pub fn rb_reserved_fd_p(fd: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_cloexec_open(pathname: *const ::libc::c_char,
                           flags: ::libc::c_int, mode: mode_t) ->
     ::libc::c_int;
    pub fn rb_cloexec_dup(oldfd: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_cloexec_dup2(oldfd: ::libc::c_int, newfd: ::libc::c_int) ->
     ::libc::c_int;
    pub fn rb_cloexec_pipe(fildes: [::libc::c_int, ..2u]) -> ::libc::c_int;
    pub fn rb_cloexec_fcntl_dupfd(fd: ::libc::c_int, minfd: ::libc::c_int) ->
     ::libc::c_int;
    pub fn rb_update_max_fd(fd: ::libc::c_int);
    pub fn rb_fd_fix_cloexec(fd: ::libc::c_int);
    pub fn rb_marshal_dump(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_marshal_load(arg1: VALUE) -> VALUE;
    pub fn rb_marshal_define_compat(newclass: VALUE, oldclass: VALUE,
                                    dumper:
                                        ::std::option::Option<extern "C" fn
                                                                  (arg1:
                                                                       VALUE)
                                                                  -> VALUE>,
                                    loader:
                                        ::std::option::Option<extern "C" fn
                                                                  (arg1:
                                                                       VALUE,
                                                                   arg2:
                                                                       VALUE)
                                                                  -> VALUE>);
    pub fn rb_num_zerodiv();
    pub fn rb_num_coerce_bin(arg1: VALUE, arg2: VALUE, arg3: ID) -> VALUE;
    pub fn rb_num_coerce_cmp(arg1: VALUE, arg2: VALUE, arg3: ID) -> VALUE;
    pub fn rb_num_coerce_relop(arg1: VALUE, arg2: VALUE, arg3: ID) -> VALUE;
    pub fn rb_num_coerce_bit(arg1: VALUE, arg2: VALUE, arg3: ID) -> VALUE;
    pub fn rb_num2fix(arg1: VALUE) -> VALUE;
    pub fn rb_fix2str(arg1: VALUE, arg2: ::libc::c_int) -> VALUE;
    pub fn rb_dbl_cmp(arg1: ::libc::c_double, arg2: ::libc::c_double) ->
     VALUE;
    pub fn rb_eql(arg1: VALUE, arg2: VALUE) -> ::libc::c_int;
    pub fn rb_any_to_s(arg1: VALUE) -> VALUE;
    pub fn rb_inspect(arg1: VALUE) -> VALUE;
    pub fn rb_obj_is_instance_of(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_obj_is_kind_of(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_obj_alloc(arg1: VALUE) -> VALUE;
    pub fn rb_obj_clone(arg1: VALUE) -> VALUE;
    pub fn rb_obj_dup(arg1: VALUE) -> VALUE;
    pub fn rb_obj_init_copy(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_obj_taint(arg1: VALUE) -> VALUE;
    pub fn rb_obj_tainted(arg1: VALUE) -> VALUE;
    pub fn rb_obj_untaint(arg1: VALUE) -> VALUE;
    pub fn rb_obj_untrust(arg1: VALUE) -> VALUE;
    pub fn rb_obj_untrusted(arg1: VALUE) -> VALUE;
    pub fn rb_obj_trust(arg1: VALUE) -> VALUE;
    pub fn rb_obj_freeze(arg1: VALUE) -> VALUE;
    pub fn rb_obj_frozen_p(arg1: VALUE) -> VALUE;
    pub fn rb_obj_id(arg1: VALUE) -> VALUE;
    pub fn rb_obj_class(arg1: VALUE) -> VALUE;
    pub fn rb_class_real(arg1: VALUE) -> VALUE;
    pub fn rb_class_inherited_p(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_class_superclass(arg1: VALUE) -> VALUE;
    pub fn rb_class_get_superclass(arg1: VALUE) -> VALUE;
    pub fn rb_convert_type(arg1: VALUE, arg2: ::libc::c_int,
                           arg3: *const ::libc::c_char,
                           arg4: *const ::libc::c_char) -> VALUE;
    pub fn rb_check_convert_type(arg1: VALUE, arg2: ::libc::c_int,
                                 arg3: *const ::libc::c_char,
                                 arg4: *const ::libc::c_char) -> VALUE;
    pub fn rb_check_to_integer(arg1: VALUE, arg2: *const ::libc::c_char) ->
     VALUE;
    pub fn rb_check_to_float(arg1: VALUE) -> VALUE;
    pub fn rb_to_int(arg1: VALUE) -> VALUE;
    pub fn rb_check_to_int(arg1: VALUE) -> VALUE;
    pub fn rb_Integer(arg1: VALUE) -> VALUE;
    pub fn rb_to_float(arg1: VALUE) -> VALUE;
    pub fn rb_Float(arg1: VALUE) -> VALUE;
    pub fn rb_String(arg1: VALUE) -> VALUE;
    pub fn rb_Array(arg1: VALUE) -> VALUE;
    pub fn rb_Hash(arg1: VALUE) -> VALUE;
    pub fn rb_cstr_to_dbl(arg1: *const ::libc::c_char, arg2: ::libc::c_int) ->
     ::libc::c_double;
    pub fn rb_str_to_dbl(arg1: VALUE, arg2: ::libc::c_int) ->
     ::libc::c_double;
    pub fn rb_id_attrset(arg1: ID) -> ID;
    pub fn rb_is_const_id(arg1: ID) -> ::libc::c_int;
    pub fn rb_is_global_id(arg1: ID) -> ::libc::c_int;
    pub fn rb_is_instance_id(arg1: ID) -> ::libc::c_int;
    pub fn rb_is_attrset_id(arg1: ID) -> ::libc::c_int;
    pub fn rb_is_class_id(arg1: ID) -> ::libc::c_int;
    pub fn rb_is_local_id(arg1: ID) -> ::libc::c_int;
    pub fn rb_is_junk_id(arg1: ID) -> ::libc::c_int;
    pub fn rb_symname_p(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn rb_sym_interned_p(arg1: VALUE) -> ::libc::c_int;
    pub fn rb_backref_get() -> VALUE;
    pub fn rb_backref_set(arg1: VALUE);
    pub fn rb_lastline_get() -> VALUE;
    pub fn rb_lastline_set(arg1: VALUE);
    pub fn rb_sym_all_symbols() -> VALUE;
    pub fn rb_last_status_set(status: ::libc::c_int, pid: pid_t);
    pub fn rb_last_status_get() -> VALUE;
    pub fn rb_proc_exec_n(arg1: ::libc::c_int, arg2: *mut VALUE,
                          arg3: *const ::libc::c_char) -> ::libc::c_int;
    pub fn rb_proc_exec(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn rb_exec_arg_init(argc: ::libc::c_int, argv: *mut VALUE,
                            accept_shell: ::libc::c_int,
                            e: *mut Struct_rb_exec_arg) -> VALUE;
    pub fn rb_exec_arg_addopt(e: *mut Struct_rb_exec_arg, key: VALUE,
                              val: VALUE) -> ::libc::c_int;
    pub fn rb_exec_arg_fixup(e: *mut Struct_rb_exec_arg);
    pub fn rb_run_exec_options(e: *const Struct_rb_exec_arg,
                               s: *mut Struct_rb_exec_arg) -> ::libc::c_int;
    pub fn rb_run_exec_options_err(e: *const Struct_rb_exec_arg,
                                   s: *mut Struct_rb_exec_arg,
                                   arg1: *mut ::libc::c_char, arg2: size_t) ->
     ::libc::c_int;
    pub fn rb_exec(arg1: *const Struct_rb_exec_arg) -> ::libc::c_int;
    pub fn rb_exec_err(arg1: *const Struct_rb_exec_arg,
                       arg2: *mut ::libc::c_char, arg3: size_t) ->
     ::libc::c_int;
    pub fn rb_fork(arg1: *mut ::libc::c_int,
                   arg2:
                       ::std::option::Option<extern "C" fn
                                                 (arg1: *mut ::libc::c_void)
                                                 -> ::libc::c_int>,
                   arg3: *mut ::libc::c_void, arg4: VALUE) -> pid_t;
    pub fn rb_fork_err(arg1: *mut ::libc::c_int,
                       arg2:
                           ::std::option::Option<extern "C" fn
                                                     (arg1:
                                                          *mut ::libc::c_void,
                                                      arg2:
                                                          *mut ::libc::c_char,
                                                      arg3: size_t)
                                                     -> ::libc::c_int>,
                       arg3: *mut ::libc::c_void, arg4: VALUE,
                       arg5: *mut ::libc::c_char, arg6: size_t) -> pid_t;
    pub fn rb_f_exec(arg1: ::libc::c_int, arg2: *mut VALUE) -> VALUE;
    pub fn rb_waitpid(pid: pid_t, status: *mut ::libc::c_int,
                      flags: ::libc::c_int) -> pid_t;
    pub fn rb_syswait(pid: pid_t);
    pub fn rb_spawn(arg1: ::libc::c_int, arg2: *mut VALUE) -> pid_t;
    pub fn rb_spawn_err(arg1: ::libc::c_int, arg2: *mut VALUE,
                        arg3: *mut ::libc::c_char, arg4: size_t) -> pid_t;
    pub fn rb_proc_times(arg1: VALUE) -> VALUE;
    pub fn rb_detach_process(pid: pid_t) -> VALUE;
    pub fn rb_range_new(arg1: VALUE, arg2: VALUE, arg3: ::libc::c_int) ->
     VALUE;
    pub fn rb_range_beg_len(arg1: VALUE, arg2: *mut ::libc::c_long,
                            arg3: *mut ::libc::c_long, arg4: ::libc::c_long,
                            arg5: ::libc::c_int) -> VALUE;
    pub fn rb_range_values(range: VALUE, begp: *mut VALUE, endp: *mut VALUE,
                           exclp: *mut ::libc::c_int) -> ::libc::c_int;
    pub fn rb_genrand_int32() -> ::libc::c_uint;
    pub fn rb_genrand_real() -> ::libc::c_double;
    pub fn rb_reset_random_seed();
    pub fn rb_random_bytes(rnd: VALUE, n: ::libc::c_long) -> VALUE;
    pub fn rb_random_int(rnd: VALUE, max: VALUE) -> VALUE;
    pub fn rb_random_int32(rnd: VALUE) -> ::libc::c_uint;
    pub fn rb_random_real(rnd: VALUE) -> ::libc::c_double;
    pub fn rb_random_ulong_limited(rnd: VALUE, limit: ::libc::c_ulong) ->
     ::libc::c_ulong;
    pub fn rb_genrand_ulong_limited(i: ::libc::c_ulong) -> ::libc::c_ulong;
    pub fn rb_memcicmp(arg1: *const ::libc::c_void,
                       arg2: *const ::libc::c_void, arg3: ::libc::c_long) ->
     ::libc::c_int;
    pub fn rb_match_busy(arg1: VALUE);
    pub fn rb_reg_nth_defined(arg1: ::libc::c_int, arg2: VALUE) -> VALUE;
    pub fn rb_reg_nth_match(arg1: ::libc::c_int, arg2: VALUE) -> VALUE;
    pub fn rb_reg_backref_number(_match: VALUE, backref: VALUE) ->
     ::libc::c_int;
    pub fn rb_reg_last_match(arg1: VALUE) -> VALUE;
    pub fn rb_reg_match_pre(arg1: VALUE) -> VALUE;
    pub fn rb_reg_match_post(arg1: VALUE) -> VALUE;
    pub fn rb_reg_match_last(arg1: VALUE) -> VALUE;
    pub fn rb_reg_new_str(arg1: VALUE, arg2: ::libc::c_int) -> VALUE;
    pub fn rb_reg_new(arg1: *const ::libc::c_char, arg2: ::libc::c_long,
                      arg3: ::libc::c_int) -> VALUE;
    pub fn rb_reg_alloc() -> VALUE;
    pub fn rb_reg_init_str(re: VALUE, s: VALUE, options: ::libc::c_int) ->
     VALUE;
    pub fn rb_reg_match(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_reg_match2(arg1: VALUE) -> VALUE;
    pub fn rb_reg_options(arg1: VALUE) -> ::libc::c_int;
    pub fn rb_get_argv() -> VALUE;
    pub fn rb_load_file(arg1: *const ::libc::c_char) -> *mut ::libc::c_void;
    pub fn rb_load_file_str(arg1: VALUE) -> *mut ::libc::c_void;
    pub fn rb_f_kill(arg1: ::libc::c_int, arg2: *mut VALUE) -> VALUE;
    pub fn ruby_posix_signal(arg1: ::libc::c_int,
                             arg2:
                                 ::std::option::Option<extern "C" fn
                                                           (arg1:
                                                                ::libc::c_int)>)
     -> ::std::option::Option<extern "C" fn(arg1: ::libc::c_int)>;
    pub fn rb_trap_exit();
    pub fn rb_trap_exec();
    pub fn ruby_signal_name(arg1: ::libc::c_int) -> *const ::libc::c_char;
    pub fn ruby_default_signal(arg1: ::libc::c_int);
    pub fn rb_f_sprintf(arg1: ::libc::c_int, arg2: *const VALUE) -> VALUE;
    pub fn rb_sprintf(arg1: *const ::libc::c_char, ...) -> VALUE;
    pub fn rb_vsprintf(arg1: *const ::libc::c_char, arg2: va_list) -> VALUE;
    pub fn rb_str_catf(arg1: VALUE, arg2: *const ::libc::c_char, ...) ->
     VALUE;
    pub fn rb_str_vcatf(arg1: VALUE, arg2: *const ::libc::c_char,
                        arg3: va_list) -> VALUE;
    pub fn rb_str_format(arg1: ::libc::c_int, arg2: *const VALUE, arg3: VALUE)
     -> VALUE;
    pub fn rb_str_new(arg1: *const ::libc::c_char, arg2: ::libc::c_long) ->
     VALUE;
    pub fn rb_str_new_cstr(arg1: *const ::libc::c_char) -> VALUE;
    pub fn rb_str_new_shared(arg1: VALUE) -> VALUE;
    pub fn rb_str_new_frozen(arg1: VALUE) -> VALUE;
    pub fn rb_str_new_with_class(arg1: VALUE, arg2: *const ::libc::c_char,
                                 arg3: ::libc::c_long) -> VALUE;
    pub fn rb_tainted_str_new_cstr(arg1: *const ::libc::c_char) -> VALUE;
    pub fn rb_tainted_str_new(arg1: *const ::libc::c_char,
                              arg2: ::libc::c_long) -> VALUE;
    pub fn rb_external_str_new(arg1: *const ::libc::c_char,
                               arg2: ::libc::c_long) -> VALUE;
    pub fn rb_external_str_new_cstr(arg1: *const ::libc::c_char) -> VALUE;
    pub fn rb_locale_str_new(arg1: *const ::libc::c_char,
                             arg2: ::libc::c_long) -> VALUE;
    pub fn rb_locale_str_new_cstr(arg1: *const ::libc::c_char) -> VALUE;
    pub fn rb_filesystem_str_new(arg1: *const ::libc::c_char,
                                 arg2: ::libc::c_long) -> VALUE;
    pub fn rb_filesystem_str_new_cstr(arg1: *const ::libc::c_char) -> VALUE;
    pub fn rb_str_buf_new(arg1: ::libc::c_long) -> VALUE;
    pub fn rb_str_buf_new_cstr(arg1: *const ::libc::c_char) -> VALUE;
    pub fn rb_str_buf_new2(arg1: *const ::libc::c_char) -> VALUE;
    pub fn rb_str_tmp_new(arg1: ::libc::c_long) -> VALUE;
    pub fn rb_usascii_str_new(arg1: *const ::libc::c_char,
                              arg2: ::libc::c_long) -> VALUE;
    pub fn rb_usascii_str_new_cstr(arg1: *const ::libc::c_char) -> VALUE;
    pub fn rb_str_free(arg1: VALUE);
    pub fn rb_str_shared_replace(arg1: VALUE, arg2: VALUE);
    pub fn rb_str_buf_append(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_str_buf_cat(arg1: VALUE, arg2: *const ::libc::c_char,
                          arg3: ::libc::c_long) -> VALUE;
    pub fn rb_str_buf_cat2(arg1: VALUE, arg2: *const ::libc::c_char) -> VALUE;
    pub fn rb_str_buf_cat_ascii(arg1: VALUE, arg2: *const ::libc::c_char) ->
     VALUE;
    pub fn rb_obj_as_string(arg1: VALUE) -> VALUE;
    pub fn rb_check_string_type(arg1: VALUE) -> VALUE;
    pub fn rb_must_asciicompat(arg1: VALUE);
    pub fn rb_str_dup(arg1: VALUE) -> VALUE;
    pub fn rb_str_resurrect(str: VALUE) -> VALUE;
    pub fn rb_str_locktmp(arg1: VALUE) -> VALUE;
    pub fn rb_str_unlocktmp(arg1: VALUE) -> VALUE;
    pub fn rb_str_dup_frozen(arg1: VALUE) -> VALUE;
    pub fn rb_str_plus(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_str_times(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_str_sublen(arg1: VALUE, arg2: ::libc::c_long) -> ::libc::c_long;
    pub fn rb_str_substr(arg1: VALUE, arg2: ::libc::c_long,
                         arg3: ::libc::c_long) -> VALUE;
    pub fn rb_str_subseq(arg1: VALUE, arg2: ::libc::c_long,
                         arg3: ::libc::c_long) -> VALUE;
    pub fn rb_str_subpos(arg1: VALUE, arg2: ::libc::c_long,
                         arg3: *mut ::libc::c_long) -> *mut ::libc::c_char;
    pub fn rb_str_modify(arg1: VALUE);
    pub fn rb_str_modify_expand(arg1: VALUE, arg2: ::libc::c_long);
    pub fn rb_str_freeze(arg1: VALUE) -> VALUE;
    pub fn rb_str_set_len(arg1: VALUE, arg2: ::libc::c_long);
    pub fn rb_str_resize(arg1: VALUE, arg2: ::libc::c_long) -> VALUE;
    pub fn rb_str_cat(arg1: VALUE, arg2: *const ::libc::c_char,
                      arg3: ::libc::c_long) -> VALUE;
    pub fn rb_str_cat2(arg1: VALUE, arg2: *const ::libc::c_char) -> VALUE;
    pub fn rb_str_append(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_str_concat(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_memhash(ptr: *const ::libc::c_void, len: ::libc::c_long) ->
     st_index_t;
    pub fn rb_hash_start(arg1: st_index_t) -> st_index_t;
    pub fn rb_hash_uint32(arg1: st_index_t, arg2: uint32_t) -> st_index_t;
    pub fn rb_hash_uint(arg1: st_index_t, arg2: st_index_t) -> st_index_t;
    pub fn rb_hash_end(arg1: st_index_t) -> st_index_t;
    pub fn rb_str_hash(arg1: VALUE) -> st_index_t;
    pub fn rb_str_hash_cmp(arg1: VALUE, arg2: VALUE) -> ::libc::c_int;
    pub fn rb_str_comparable(arg1: VALUE, arg2: VALUE) -> ::libc::c_int;
    pub fn rb_str_cmp(arg1: VALUE, arg2: VALUE) -> ::libc::c_int;
    pub fn rb_str_equal(str1: VALUE, str2: VALUE) -> VALUE;
    pub fn rb_str_drop_bytes(arg1: VALUE, arg2: ::libc::c_long) -> VALUE;
    pub fn rb_str_update(arg1: VALUE, arg2: ::libc::c_long,
                         arg3: ::libc::c_long, arg4: VALUE);
    pub fn rb_str_replace(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_str_inspect(arg1: VALUE) -> VALUE;
    pub fn rb_str_dump(arg1: VALUE) -> VALUE;
    pub fn rb_str_split(arg1: VALUE, arg2: *const ::libc::c_char) -> VALUE;
    pub fn rb_str_associate(arg1: VALUE, arg2: VALUE);
    pub fn rb_str_associated(arg1: VALUE) -> VALUE;
    pub fn rb_str_setter(arg1: VALUE, arg2: ID, arg3: *mut VALUE);
    pub fn rb_str_intern(arg1: VALUE) -> VALUE;
    pub fn rb_sym_to_s(arg1: VALUE) -> VALUE;
    pub fn rb_str_strlen(arg1: VALUE) -> ::libc::c_long;
    pub fn rb_str_length(arg1: VALUE) -> VALUE;
    pub fn rb_str_offset(arg1: VALUE, arg2: ::libc::c_long) -> ::libc::c_long;
    pub fn rb_str_capacity(arg1: VALUE) -> size_t;
    pub fn rb_str_ellipsize(arg1: VALUE, arg2: ::libc::c_long) -> VALUE;
    pub fn rb_str_scrub(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_struct_new(arg1: VALUE, ...) -> VALUE;
    pub fn rb_struct_define(arg1: *const ::libc::c_char, ...) -> VALUE;
    pub fn rb_struct_define_under(arg1: VALUE,
                                  arg2: *const ::libc::c_char, ...) -> VALUE;
    pub fn rb_struct_alloc(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_struct_initialize(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_struct_aref(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_struct_aset(arg1: VALUE, arg2: VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_struct_getmember(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_struct_iv_get(arg1: VALUE, arg2: *const ::libc::c_char) ->
     VALUE;
    pub fn rb_struct_s_members(arg1: VALUE) -> VALUE;
    pub fn rb_struct_members(arg1: VALUE) -> VALUE;
    pub fn rb_struct_alloc_noinit(arg1: VALUE) -> VALUE;
    pub fn rb_struct_define_without_accessor(arg1: *const ::libc::c_char,
                                             arg2: VALUE,
                                             arg3: rb_alloc_func_t, ...) ->
     VALUE;
    pub fn rb_struct_define_without_accessor_under(outer: VALUE,
                                                   class_name:
                                                       *const ::libc::c_char,
                                                   _super: VALUE,
                                                   alloc:
                                                       rb_alloc_func_t, ...)
     -> VALUE;
    pub fn rb_thread_check_ints();
    pub fn rb_thread_interrupted(thval: VALUE) -> ::libc::c_int;
    pub fn rb_thread_blocking_region(func:
                                         *mut ::std::option::Option<extern "C" fn
                                                                        (arg1:
                                                                             *mut ::libc::c_void)
                                                                        ->
                                                                            VALUE>,
                                     data1: *mut ::libc::c_void,
                                     ubf:
                                         *mut ::std::option::Option<extern "C" fn
                                                                        (arg1:
                                                                             *mut ::libc::c_void)>,
                                     data2: *mut ::libc::c_void) -> VALUE;
    pub fn rb_mutex_new() -> VALUE;
    pub fn rb_mutex_locked_p(mutex: VALUE) -> VALUE;
    pub fn rb_mutex_trylock(mutex: VALUE) -> VALUE;
    pub fn rb_mutex_lock(mutex: VALUE) -> VALUE;
    pub fn rb_mutex_unlock(mutex: VALUE) -> VALUE;
    pub fn rb_mutex_sleep(_self: VALUE, timeout: VALUE) -> VALUE;
    pub fn rb_mutex_synchronize(mutex: VALUE,
                                func:
                                    ::std::option::Option<extern "C" fn
                                                              (arg1: VALUE)
                                                              -> VALUE>,
                                arg: VALUE) -> VALUE;
    pub fn rb_time_new(arg1: time_t, arg2: ::libc::c_long) -> VALUE;
    pub fn rb_time_nano_new(arg1: time_t, arg2: ::libc::c_long) -> VALUE;
    pub fn rb_time_num_new(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_time_interval(num: VALUE) -> Struct_timeval;
    pub fn rb_time_timeval(time: VALUE) -> Struct_timeval;
    pub fn rb_time_timespec(time: VALUE) -> Struct_timespec;
    pub fn rb_mod_name(arg1: VALUE) -> VALUE;
    pub fn rb_class_path(arg1: VALUE) -> VALUE;
    pub fn rb_class_path_cached(arg1: VALUE) -> VALUE;
    pub fn rb_set_class_path(arg1: VALUE, arg2: VALUE,
                             arg3: *const ::libc::c_char);
    pub fn rb_set_class_path_string(arg1: VALUE, arg2: VALUE, arg3: VALUE);
    pub fn rb_path_to_class(arg1: VALUE) -> VALUE;
    pub fn rb_path2class(arg1: *const ::libc::c_char) -> VALUE;
    pub fn rb_name_class(arg1: VALUE, arg2: ID);
    pub fn rb_class_name(arg1: VALUE) -> VALUE;
    pub fn rb_autoload(arg1: VALUE, arg2: ID, arg3: *const ::libc::c_char);
    pub fn rb_autoload_load(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_autoload_p(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_f_trace_var(arg1: ::libc::c_int, arg2: *mut VALUE) -> VALUE;
    pub fn rb_f_untrace_var(arg1: ::libc::c_int, arg2: *mut VALUE) -> VALUE;
    pub fn rb_f_global_variables() -> VALUE;
    pub fn rb_alias_variable(arg1: ID, arg2: ID);
    pub fn rb_generic_ivar_table(arg1: VALUE) -> *mut Struct_st_table;
    pub fn rb_copy_generic_ivar(arg1: VALUE, arg2: VALUE);
    pub fn rb_free_generic_ivar(arg1: VALUE);
    pub fn rb_ivar_get(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_ivar_set(arg1: VALUE, arg2: ID, arg3: VALUE) -> VALUE;
    pub fn rb_ivar_defined(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_ivar_foreach(arg1: VALUE,
                           arg2:
                               ::std::option::Option<extern "C" fn()
                                                         -> ::libc::c_int>,
                           arg3: st_data_t);
    pub fn rb_ivar_count(arg1: VALUE) -> st_index_t;
    pub fn rb_attr_get(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_obj_instance_variables(arg1: VALUE) -> VALUE;
    pub fn rb_obj_remove_instance_variable(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_mod_const_at(arg1: VALUE, arg2: *mut ::libc::c_void) ->
     *mut ::libc::c_void;
    pub fn rb_mod_const_of(arg1: VALUE, arg2: *mut ::libc::c_void) ->
     *mut ::libc::c_void;
    pub fn rb_const_list(arg1: *mut ::libc::c_void) -> VALUE;
    pub fn rb_mod_constants(arg1: ::libc::c_int, arg2: *mut VALUE,
                            arg3: VALUE) -> VALUE;
    pub fn rb_mod_remove_const(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_const_defined(arg1: VALUE, arg2: ID) -> ::libc::c_int;
    pub fn rb_const_defined_at(arg1: VALUE, arg2: ID) -> ::libc::c_int;
    pub fn rb_const_defined_from(arg1: VALUE, arg2: ID) -> ::libc::c_int;
    pub fn rb_const_get(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_const_get_at(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_const_get_from(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_const_set(arg1: VALUE, arg2: ID, arg3: VALUE);
    pub fn rb_const_remove(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_mod_const_missing(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_cvar_defined(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_cvar_set(arg1: VALUE, arg2: ID, arg3: VALUE);
    pub fn rb_cvar_get(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_cv_set(arg1: VALUE, arg2: *const ::libc::c_char, arg3: VALUE);
    pub fn rb_cv_get(arg1: VALUE, arg2: *const ::libc::c_char) -> VALUE;
    pub fn rb_define_class_variable(arg1: VALUE, arg2: *const ::libc::c_char,
                                    arg3: VALUE);
    pub fn rb_mod_class_variables(arg1: ::libc::c_int, arg2: *mut VALUE,
                                  arg3: VALUE) -> VALUE;
    pub fn rb_mod_remove_cvar(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_frame_callee() -> ID;
    pub fn rb_str_succ(arg1: VALUE) -> VALUE;
    pub fn rb_time_succ(arg1: VALUE) -> VALUE;
    pub fn rb_frame_pop();
    pub fn rb_frame_method_id_and_class(idp: *mut ID, klassp: *mut VALUE) ->
     ::libc::c_int;
    pub fn rb_make_backtrace() -> VALUE;
    pub fn rb_make_exception(arg1: ::libc::c_int, arg2: *mut VALUE) -> VALUE;
    pub fn ruby_native_thread_p() -> ::libc::c_int;
    pub fn rb_add_event_hook(func: rb_event_hook_func_t,
                             events: rb_event_flag_t, data: VALUE);
    pub fn rb_remove_event_hook(func: rb_event_hook_func_t) -> ::libc::c_int;
    pub fn rb_isalnum(c: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_isalpha(c: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_isblank(c: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_iscntrl(c: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_isdigit(c: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_isgraph(c: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_islower(c: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_isprint(c: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_ispunct(c: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_isspace(c: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_isupper(c: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_isxdigit(c: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_tolower(c: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_toupper(c: ::libc::c_int) -> ::libc::c_int;
    pub fn ruby_strtoul(str: *const ::libc::c_char,
                        endptr: *mut *mut ::libc::c_char, base: ::libc::c_int)
     -> ::libc::c_ulong;
    pub fn ruby_snprintf(str: *mut ::libc::c_char, n: size_t,
                         fmt: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn ruby_vsnprintf(str: *mut ::libc::c_char, n: size_t,
                          fmt: *const ::libc::c_char, ap: va_list) ->
     ::libc::c_int;
    pub fn ruby_sysinit(argc: *mut ::libc::c_int,
                        argv: *mut *mut *mut ::libc::c_char);
    pub fn ruby_init();
    pub fn ruby_options(argc: ::libc::c_int, argv: *mut *mut ::libc::c_char)
     -> *mut ::libc::c_void;
    pub fn ruby_executable_node(n: *mut ::libc::c_void,
                                status: *mut ::libc::c_int) -> ::libc::c_int;
    pub fn ruby_run_node(n: *mut ::libc::c_void) -> ::libc::c_int;
    pub fn ruby_show_version();
    pub fn ruby_show_copyright();
    pub fn ruby_init_stack(arg1: *mut VALUE);
    pub fn ruby_setup() -> ::libc::c_int;
    pub fn ruby_cleanup(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn ruby_finalize();
    pub fn ruby_stop(arg1: ::libc::c_int);
    pub fn ruby_set_stack_size(arg1: size_t);
    pub fn ruby_stack_check() -> ::libc::c_int;
    pub fn ruby_stack_length(arg1: *mut *mut VALUE) -> size_t;
    pub fn ruby_exec_node(n: *mut ::libc::c_void) -> ::libc::c_int;
    pub fn ruby_script(name: *const ::libc::c_char);
    pub fn ruby_set_script_name(name: VALUE);
    pub fn ruby_prog_init();
    pub fn ruby_set_argv(arg1: ::libc::c_int, arg2: *mut *mut ::libc::c_char);
    pub fn ruby_process_options(arg1: ::libc::c_int,
                                arg2: *mut *mut ::libc::c_char) ->
     *mut ::libc::c_void;
    pub fn ruby_init_loadpath();
    pub fn ruby_incpush(arg1: *const ::libc::c_char);
    pub fn ruby_sig_finalize();
}
